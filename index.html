<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"
  />
  <title>Neon Dash (Geometry-Dash-style)</title>

  <style>
    /* =============================================================================
       NEON DASH — Single-file, Canvas-based, Geometry-Dash-style runner
       - No external build tools
       - No external audio files (WebAudio synth music + SFX)
       - Mobile friendly
       Authored by Phu Trung (Luke) Nguyen
       25 December 2025
       ============================================================================= */

    /* Music menu */
    .musicBox{
    margin-top: 12px;
    padding-top: 12px;
    border-top: 1px solid rgba(255,255,255,0.10);
    }
    .musicLabel{
    font-family: var(--mono);
    font-size: 12px;
    color: var(--txtDim);
    letter-spacing: 0.06em;
    margin-bottom: 8px;
    text-transform: uppercase;
    }
    .musicRow{
    display: flex;
    gap: 10px;
    align-items: center;
    flex-wrap: wrap;
    }
    .select{
    appearance: none;
    border: 1px solid var(--stroke2);
    background: var(--btn);
    color: var(--txt);
    border-radius: var(--radius2);
    padding: 10px 12px;
    font-family: var(--mono);
    font-weight: 700;
    font-size: 12px;
    letter-spacing: 0.02em;
    cursor: pointer;
    min-width: 220px;
    color-scheme: dark;
    padding-right: 34px;
    }

    .select:hover{
    background: var(--btnH);
    border-color: rgba(255,255,255,0.35);
    }

    .select:focus{
      outline: none;
      border-color: rgba(125, 249, 255, 0.55);
      box-shadow: 0 0 0 3px rgba(125, 249, 255, 0.18);
    }

    /* Style the dropdown list itself (Chromium supports this reasonably well) */
    .select option{
      background: rgba(10, 10, 25, 0.98); /* matches your panel vibe */
      color: var(--txt);
    }

    .select option:disabled{
      color: var(--txtDim);
    }

    .selectWrap{
      position: relative;
      display: inline-block;
      min-width: 220px; /* same as your select */
    }

    .selectWrap::after{
      content: "▾";
      position: absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      color: var(--txtDim);
      pointer-events: none; /* keep clicks going to the select */
      font-family: var(--mono);
      font-weight: 800;
    }


    :root
    {
      --bg0: #060612;
      --bg1: #0b0b20;
      --bg2: #120a22;

      --neonA: #7df9ff;
      --neonB: #ff4dff;
      --neonC: #7cfc9a;
      --neonD: #ffd36b;

      --panel: rgba(10, 10, 25, 0.78);
      --panel2: rgba(20, 12, 35, 0.78);

      --stroke: rgba(255, 255, 255, 0.15);
      --stroke2: rgba(255, 255, 255, 0.22);

      --shadow: rgba(0, 0, 0, 0.35);

      --txt: rgba(255, 255, 255, 0.92);
      --txtDim: rgba(255, 255, 255, 0.70);
      --txtFaint: rgba(255, 255, 255, 0.55);

      --btn: rgba(255, 255, 255, 0.08);
      --btnH: rgba(255, 255, 255, 0.16);
      --btnA: rgba(255, 255, 255, 0.22);

      --radius: 14px;
      --radius2: 10px;

      --hudGap: 10px;

      --mono:
        ui-monospace,
        SFMono-Regular,
        Menlo,
        Monaco,
        Consolas,
        "Liberation Mono",
        "Courier New",
        monospace;

      --ui:
        system-ui,
        -apple-system,
        Segoe UI,
        Roboto,
        Helvetica,
        Arial,
        "Apple Color Emoji",
        "Segoe UI Emoji";
    }

    html,
    body
    {
      height: 100%;
      margin: 0;
      background: radial-gradient(
        1200px 800px at 30% 10%,
        var(--bg2),
        var(--bg1),
        var(--bg0)
      );
      overflow: hidden;
      font-family: var(--ui);
      color: var(--txt);
    }

    #app
    {
      position: relative;
      width: 100%;
      height: 100%;
      user-select: none;
      -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    canvas#game
    {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      background: transparent;
    }

    /* =============================================================================
       HUD (Score / Best / Speed + Buttons)
       ============================================================================= */

    #hud
    {
      position: absolute;
      left: 14px;
      top: 14px;
      right: 14px;
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 14px;
      pointer-events: none; /* allow clicks through except on buttons */
    }

    .hudBox
    {
      pointer-events: auto;
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      border: 1px solid var(--stroke2);
      border-radius: var(--radius);
      box-shadow:
        0 12px 32px var(--shadow),
        0 0 28px rgba(125, 249, 255, 0.10),
        0 0 28px rgba(255, 77, 255, 0.08);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    .hudLeft
    {
      padding: 12px 14px;
      min-width: 220px;
    }

    .hudRight
    {
      padding: 10px 10px;
      display: flex;
      align-items: center;
      gap: var(--hudGap);
    }

    .hudTitle
    {
      font-family: var(--mono);
      letter-spacing: 0.12em;
      font-weight: 800;
      font-size: 12px;
      color: var(--txtDim);
      margin-bottom: 8px;
      text-transform: uppercase;
    }

    .hudRow
    {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      align-items: baseline;
      line-height: 1.2;
      margin: 2px 0;
      font-family: var(--mono);
    }

    .hudRow span:first-child
    {
      color: var(--txtFaint);
      font-size: 12px;
      letter-spacing: 0.02em;
    }

    .hudRow span:last-child
    {
      color: var(--txt);
      font-size: 13px;
      font-weight: 700;
    }

    .btn
    {
      appearance: none;
      border: 1px solid var(--stroke2);
      background: var(--btn);
      color: var(--txt);
      border-radius: var(--radius2);
      padding: 10px 12px;
      font-family: var(--mono);
      font-weight: 700;
      font-size: 12px;
      letter-spacing: 0.02em;
      cursor: pointer;
      box-shadow:
        0 10px 22px rgba(0, 0, 0, 0.22),
        inset 0 0 0 1px rgba(255, 255, 255, 0.05);
      transition:
        transform 120ms ease,
        background 120ms ease,
        border-color 120ms ease;
    }

    .btn:hover
    {
      background: var(--btnH);
      border-color: rgba(255, 255, 255, 0.35);
      transform: translateY(-1px);
    }

    .btn:active
    {
      background: var(--btnA);
      transform: translateY(0px);
    }

    .btn.big
    {
      font-size: 13px;
      padding: 12px 14px;
    }

    .btn.primary
    {
      border-color: rgba(125, 249, 255, 0.55);
      box-shadow:
        0 10px 22px rgba(0, 0, 0, 0.24),
        0 0 18px rgba(125, 249, 255, 0.12),
        inset 0 0 0 1px rgba(125, 249, 255, 0.12);
    }

    .btn.danger
    {
      border-color: rgba(255, 77, 255, 0.55);
      box-shadow:
        0 10px 22px rgba(0, 0, 0, 0.24),
        0 0 18px rgba(255, 77, 255, 0.12),
        inset 0 0 0 1px rgba(255, 77, 255, 0.10);
    }

    /* =============================================================================
       Overlay (Menu / Game Over)
       ============================================================================= */

    #overlay
    {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 18px;
      background: radial-gradient(
        800px 500px at 50% 45%,
        rgba(0, 0, 0, 0.28),
        rgba(0, 0, 0, 0.65)
      );
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
    }

    #overlay.hidden
    {
      display: none;
    }

    .panel
    {
      width: min(560px, 96vw);
      border-radius: 18px;
      border: 1px solid var(--stroke2);
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      box-shadow:
        0 24px 60px rgba(0, 0, 0, 0.50),
        0 0 40px rgba(125, 249, 255, 0.10),
        0 0 40px rgba(255, 77, 255, 0.08);
      padding: 18px 18px 14px 18px;
    }

    .panelHeader
    {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 14px;
      margin-bottom: 10px;
    }

    .panelTitle
    {
      font-family: var(--mono);
      font-weight: 900;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      font-size: 18px;
      margin: 0;
      line-height: 1.0;
    }

    .panelSubtitle
    {
      font-family: var(--mono);
      font-size: 12px;
      color: var(--txtDim);
      letter-spacing: 0.06em;
      margin-top: 6px;
    }

    .panelBody
    {
      margin-top: 12px;
      padding: 14px 14px;
      border: 1px solid rgba(255, 255, 255, 0.10);
      border-radius: 14px;
      background: rgba(0, 0, 0, 0.18);
    }

    .panelBody p
    {
      margin: 0 0 10px 0;
      color: var(--txt);
      line-height: 1.45;
      font-size: 14px;
    }

    .panelBody .hintLine
    {
      margin-top: 8px;
      color: var(--txtDim);
      font-family: var(--mono);
      font-size: 12px;
      line-height: 1.35;
    }

    .panelActions{
    margin-top: 12px;
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    justify-content: flex-end;
    }

    .tagRow
    {
      margin-top: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .tag
    {
      font-family: var(--mono);
      font-size: 11px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(255, 255, 255, 0.06);
      color: var(--txtDim);
      letter-spacing: 0.02em;
    }

    /* =============================================================================
       Tiny toast (optional)
       ============================================================================= */

    #toast
    {
      position: absolute;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.44);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 999px;
      padding: 10px 14px;
      font-family: var(--mono);
      font-size: 12px;
      color: var(--txtDim);
      box-shadow: 0 14px 30px rgba(0, 0, 0, 0.30);
    }

    #toast.hidden
    {
      display: none;
    }

    /* =============================================================================
       Mobile tweaks
       ============================================================================= */

    @media (max-width: 520px)
    {
      .hudLeft
      {
        min-width: 0;
        padding: 10px 12px;
      }

      .hudRow span:first-child
      {
        font-size: 11px;
      }

      .hudRow span:last-child
      {
        font-size: 12px;
      }

      .btn
      {
        padding: 10px 10px;
      }

      .panelTitle
      {
        font-size: 16px;
      }
    }
  </style>
</head>

<body>
  <div id="app">
    <canvas id="game"></canvas>

    <div id="hud">
      <div class="hudBox hudLeft">
        <div class="hudTitle">NEON DASH</div>

        <div class="hudRow">
          <span>Score</span>
          <span id="uiScore">0</span>
        </div>

        <div class="hudRow">
          <span>Best</span>
          <span id="uiBest">0</span>
        </div>

        <div class="hudRow">
          <span>Speed</span>
          <span id="uiSpeed">1.00x</span>
        </div>

        <div class="hudRow">
          <span>State</span>
          <span id="uiState">MENU</span>
        </div>
      </div>

      <div class="hudBox hudRight">
        <button id="btnMute" class="btn">Mute (M)</button>
        <button id="btnRestartTop" class="btn danger">Restart (R)</button>
      </div>
    </div>

    <div id="overlay">
      <div class="panel">
        <div class="panelHeader">
          <div>
            <h1 class="panelTitle" id="panelTitle">NEON DASH</h1>
            <div class="panelSubtitle" id="panelSubtitle">
              Geometry-Dash-style rhythm runner
            </div>
          </div>
          <div class="tagRow">
            <span class="tag" id="tagA">60fps</span>
            <span class="tag" id="tagB">WebAudio</span>
            <span class="tag" id="tagC">Procedural</span>
          </div>
        </div>

        <div class="panelBody">
        <p id="panelText">
            Press <b>Start</b> to start.<br/>
            Time your jumps. One hit = boom.
        </p>

        <!-- Music menu (MENU + GAMEOVER) -->
        <div id="musicPanel" class="musicBox">
            <div class="musicLabel">Music</div>

            <div class="musicRow">
            <select id="musicSelect" class="select"></select>
            <button id="btnPreview" class="btn">Preview</button>
            </div>
        </div>

        <div class="hintLine">
            Jump: Space / Up / Click / Tap<br/>
            Restart: R (or tap after death)<br/>
            Mute: M
        </div>
        </div>

        <div class="panelActions">
        <button id="btnStart" class="btn big primary">Start</button>
        <button id="btnRestart" class="btn big danger" style="display:none;">Restart</button>
        </div>
      </div>
    </div>

    <div id="toast" class="hidden">Audio unlocked ✓</div>
  </div>

  <script>
    "use strict";

    /* =============================================================================
       NEON DASH — JavaScript
       =============================================================================
       Key goals:
       - Constant forward motion (world scroll)
       - Jump timing feels “snappy” with:
         * coyote time (grace after leaving ground)
         * jump buffering (press slightly early, jumps on landing)
       - Procedural obstacles (fair + difficulty ramps)
       - Collision (AABB for blocks, triangle intersection for spikes)
       - Game states (Menu → Playing → Game Over) + instant restart
       - Polished UI + neon visuals + parallax background
       - WebAudio music + jump/death SFX with autoplay restrictions handled
       ============================================================================= */

    /* =============================================================================
       DOM
       ============================================================================= */
    const musicPanel =
        document.getElementById("musicPanel");

    const musicSelect =
        document.getElementById("musicSelect");

    const btnPreview =
        document.getElementById("btnPreview");

    const canvas =
      document.getElementById("game");

    const ctx =
      canvas.getContext("2d", { alpha: true });

    const uiScore =
      document.getElementById("uiScore");

    const uiBest =
      document.getElementById("uiBest");

    const uiSpeed =
      document.getElementById("uiSpeed");

    const uiState =
      document.getElementById("uiState");

    const overlay =
      document.getElementById("overlay");

    const panelTitle =
      document.getElementById("panelTitle");

    const panelSubtitle =
      document.getElementById("panelSubtitle");

    const panelText =
      document.getElementById("panelText");

    const btnStart =
      document.getElementById("btnStart");

    const btnRestart =
      document.getElementById("btnRestart");

    const btnMute =
      document.getElementById("btnMute");

    const btnRestartTop =
      document.getElementById("btnRestartTop");

    const toast =
      document.getElementById("toast");

    /* =============================================================================
       Utility — math helpers
       ============================================================================= */

    const clamp =
      (v, a, b) =>
        Math.max(a, Math.min(b, v));

    const lerp =
      (a, b, t) =>
        a + (b - a) * t;

    const rand =
      (a, b) =>
        a + Math.random() * (b - a);

    const randInt =
      (a, b) =>
        Math.floor(rand(a, b + 1));

    const sign =
      (v) =>
        v < 0 ? -1 : 1;

    const TAU =
      Math.PI * 2;

    /* =============================================================================
       Config (tuned for “Geometry Dash” feel)
       ============================================================================= */

    const CONFIG =
    {
      // Rendering
      dprMax:
        2.0,

      // World layout
      groundFrac:
        0.80,           // ground line Y = height * groundFrac

      // Player
      playerSize:
        42,

      playerXFrac:
        0.25,           // player's fixed screen X = width * playerXFrac

      gravity:
        3400,           // px/s^2

      jumpSpeed:
        1180,           // px/s (impulse)

      maxFallSpeed:
        2100,           // clamp

      // “Geometry Dash” niceties
      coyoteTime:
        0.085,          // seconds

      jumpBuffer:
        0.105,          // seconds

      // Rotation visuals
      rotPerSecond:
        9.0,            // base rotation speed

      rotSnapStrength:
        18.0,           // landing rotation smoothing

      // Difficulty curve
      baseSpeed:
        560,            // px/s

      maxSpeed:
        980,            // px/s

      speedRampPerSec:
        10.5,           // px/s per second

      // Spawn control
      spawnAhead:
        1200,           // how far ahead we ensure spawns exist (world units)

      minGap:
        240,            // minimum pattern gap

      maxGap:
        520,            // maximum pattern gap

      // Obstacle sizes
      spikeWidth:
        44,

      spikeHeight:
        42,

      blockMin:
        44,

      blockMax:
        68,

      // Particles
      trailRate:
        70,             // per second

      deathParticles:
        95,

      // Screen shake
      shakeTime:
        0.22,

      shakeMag:
        14,

      // Scoring
      scorePerUnit:
        0.010,          // score += speed * dt * scorePerUnit
                         // (distance based)

      // Beat pulse (visual + music)
      bpm:
        138,

      // Fixed timestep
      fixedDt:
        1 / 120,

      maxFrameDt:
        1 / 20,
    };

    /* =============================================================================
       Global runtime values (set on resize)
       ============================================================================= */

    let W = 0;
    let H = 0;

    let DPR = 1;

    let groundY = 0;
    let playerX = 0;

    function resizeCanvas()
    {
      DPR =
        Math.min(
          CONFIG.dprMax,
          window.devicePixelRatio || 1
        );

      W =
        Math.floor(window.innerWidth);

      H =
        Math.floor(window.innerHeight);

      canvas.width =
        Math.floor(W * DPR);

      canvas.height =
        Math.floor(H * DPR);

      canvas.style.width =
        W + "px";

      canvas.style.height =
        H + "px";

      ctx.setTransform(
        DPR, 0,
        0, DPR,
        0, 0
      );

      groundY =
        Math.floor(H * CONFIG.groundFrac);

      playerX =
        Math.floor(W * CONFIG.playerXFrac);
    }

    window.addEventListener("resize", resizeCanvas);

    resizeCanvas();

    /* =============================================================================
       Audio Manager (WebAudio synth music + SFX)
       =============================================================================
       - Autoplay restrictions: only start after user interaction.
       - Music loops via scheduled notes.
       - Mute toggles master gain.
       ============================================================================= */

    class AudioManager
    {
      constructor()
      {
        this.ctx = null;
        this.musicEl = null;              // HTMLAudioElement for MP3 music
        this.trackId = "synth";           // selected track id
        this.trackType = "synth";         // "synth" | "file" | "off"
        this.trackUrl = "";               // for file tracks
        this.previewing = false;
        this.fileMusicVolume = 0.55;

        this.master =
          null;

        this.musicGain =
          null;

        this.sfxGain =
          null;

        this.muted =
          false;

        this.unlocked =
          false;

        this.musicOn =
          false;

        this.bpm =
          CONFIG.bpm;

        this.beatDur =
          60 / this.bpm;

        this.musicTimer =
          0;

        this.musicStep =
          0;

        this.nextNoteTime =
          0;

        this._notes =
          [
            220.00, // A3
            246.94, // B3
            261.63, // C4
            293.66, // D4
            329.63, // E4
            392.00, // G4
          ];

        this._pattern =
          [
            0, 2, 4, 2,
            1, 3, 5, 3,
            0, 2, 4, 2,
            1, 3, 5, 4,
          ];

        this._chord =
          [ 0, 4, 5 ];

        this._startedAt =
          0;
      }
      _ensureMusicEl()
        {
        if (this.musicEl) return;

        this.musicEl = new Audio();
        this.musicEl.loop = true;
        this.musicEl.preload = "auto";
        this.musicEl.volume = this.fileMusicVolume;
        this.musicEl.muted = this.muted;
        }

        setMusicTrack(track)
        {
        // track = { id, type, url? }
        if (!track) return;

        // stop any current music before switching
        this.stopMusic();

        this.trackId = track.id;
        this.trackType = track.type;

        if (track.type === "file")
        {
            this.trackUrl = track.url || "";
            this._ensureMusicEl();
            this.musicEl.src = this.trackUrl;
        }
        else
        {
            this.trackUrl = "";
            if (this.musicEl) this.musicEl.removeAttribute("src");
        }
        }

        async _playFileMusic()
        {
        this._ensureMusicEl();
        if (!this.trackUrl) return;

        this.musicEl.muted = this.muted;
        this.musicEl.volume = this.fileMusicVolume;

        try
        {
            await this.musicEl.play();
        }
        catch (e)
        {
            // autoplay restrictions or load fail — will work after another gesture
        }
        }

        _stopFileMusic()
        {
        if (!this.musicEl) return;
        this.musicEl.pause();
        this.musicEl.currentTime = 0;
        }

        isPreviewing()
        {
        return this.previewing;
        }

        async previewToggle()
        {
        // Preview only matters for file tracks; for synth we just start/stop synth music.
        if (this.trackType === "off")
        {
            this.previewing = false;
            this.stopMusic();
            return;
        }

        if (!this.previewing)
        {
            this.previewing = true;
            this.startMusic(); // reuse start logic
        }
        else
        {
            this.previewing = false;
            this.stopMusic();
        }
        }


      ensure()
      {
        if (this.ctx) return;

        const AC =
          window.AudioContext ||
          window.webkitAudioContext;

        this.ctx =
          new AC();

        this.master =
          this.ctx.createGain();

        this.musicGain =
          this.ctx.createGain();

        this.sfxGain =
          this.ctx.createGain();

        this.master.gain.value =
          0.85;

        this.musicGain.gain.value =
          0.45;

        this.sfxGain.gain.value =
          0.65;

        this.musicGain.connect(this.master);
        this.sfxGain.connect(this.master);

        this.master.connect(this.ctx.destination);

        this._startedAt =
          this.ctx.currentTime;

        this.nextNoteTime =
          this.ctx.currentTime + 0.05;
      }

      async unlock()
      {
        this.ensure();

        if (this.unlocked) return;

        try
        {
          await this.ctx.resume();
          this.unlocked = true;
          showToast("Audio unlocked ✓");
        }
        catch (e)
        {
          // If resume fails, we'll try again on next user input.
        }
      }

    setMuted(flag)
    {
    this.muted = !!flag;

    if (this.master)
    {
        this.master.gain.value =
        this.muted ? 0.0 : 0.85;
    }

    if (this.musicEl)
    {
        this.musicEl.muted = this.muted;
    }

    btnMute.textContent =
        this.muted ? "Unmute (M)" : "Mute (M)";
    }


      toggleMute()
      {
        this.setMuted(!this.muted);
      }

    startMusic()
    {
    this.ensure();

    if (this.trackType === "off")
    {
        this.musicOn = false;
        this._stopFileMusic();
        return;
    }

    if (this.trackType === "file")
    {
        this.musicOn = false;     // synth scheduler off
        this._playFileMusic();
        return;
    }

    // default: synth
    this._stopFileMusic();

    this.musicOn = true;
    this.musicStep = 0;
    this.nextNoteTime = this.ctx.currentTime + 0.05;
    }


    stopMusic()
    {
    this.musicOn = false;   // stops synth scheduling
    this._stopFileMusic();  // stops mp3 if any
    this.previewing = false;
    }

      // Called frequently (each update) to schedule notes slightly ahead.
      tickMusic()
      {
        if (!this.ctx) return;
        if (!this.musicOn) return;       // synth only
        if (!this.unlocked) return;
        if (this.muted) return;

        const scheduleAhead =
          0.25;

        while (this.nextNoteTime < this.ctx.currentTime + scheduleAhead)
        {
          const stepIndex =
            this.musicStep % this._pattern.length;

          const noteIndex =
            this._pattern[stepIndex];

          const baseFreq =
            this._notes[noteIndex];

          const isKick =
            (this.musicStep % 4) === 0;

          const isSnare =
            (this.musicStep % 4) === 2;

          // melody blip
          this._playSynthNote(
            baseFreq,
            this.nextNoteTime,
            0.08,
            isKick ? 0.22 : 0.14
          );

          // chord pad every 8 steps
          if ((this.musicStep % 8) === 0)
          {
            const c0 =
              this._notes[this._chord[0]];

            const c1 =
              this._notes[this._chord[1]];

            const c2 =
              this._notes[this._chord[2]];

            this._playPadChord(
              [c0, c1, c2],
              this.nextNoteTime,
              0.28,
              0.12
            );

            // rotate chord occasionally
            if ((this.musicStep % 16) === 0)
            {
              this._chord.unshift(this._chord.pop());
            }
          }

          // soft kick / snare using noise + low osc
          if (isKick)
          {
            this._playKick(
              this.nextNoteTime,
              0.09,
              0.45
            );
          }
          else if (isSnare)
          {
            this._playSnare(
              this.nextNoteTime,
              0.08,
              0.25
            );
          }

          // advance
          this.musicStep += 1;
          this.nextNoteTime += this.beatDur / 2; // eighth notes
        }
      }

      _playSynthNote(freq, time, dur, amp)
      {
        const osc =
          this.ctx.createOscillator();

        const g =
          this.ctx.createGain();

        osc.type =
          "square";

        osc.frequency.setValueAtTime(freq, time);

        // tiny detune for thickness
        osc.detune.setValueAtTime(rand(-6, 6), time);

        g.gain.setValueAtTime(0.0, time);
        g.gain.linearRampToValueAtTime(amp, time + 0.01);
        g.gain.exponentialRampToValueAtTime(0.001, time + dur);

        osc.connect(g);
        g.connect(this.musicGain);

        osc.start(time);
        osc.stop(time + dur + 0.03);
      }

      _playPadChord(freqs, time, dur, amp)
      {
        for (let i = 0; i < freqs.length; i++)
        {
          const osc =
            this.ctx.createOscillator();

          const g =
            this.ctx.createGain();

          osc.type =
            "sine";

          osc.frequency.setValueAtTime(freqs[i], time);
          osc.detune.setValueAtTime(rand(-10, 10), time);

          g.gain.setValueAtTime(0.0, time);
          g.gain.linearRampToValueAtTime(amp, time + 0.02);
          g.gain.exponentialRampToValueAtTime(0.001, time + dur);

          osc.connect(g);
          g.connect(this.musicGain);

          osc.start(time);
          osc.stop(time + dur + 0.05);
        }
      }

      _playKick(time, dur, amp)
      {
        // low sine pitch drop + short envelope
        const osc =
          this.ctx.createOscillator();

        const g =
          this.ctx.createGain();

        osc.type =
          "sine";

        osc.frequency.setValueAtTime(120, time);
        osc.frequency.exponentialRampToValueAtTime(45, time + dur);

        g.gain.setValueAtTime(0.0, time);
        g.gain.linearRampToValueAtTime(amp, time + 0.006);
        g.gain.exponentialRampToValueAtTime(0.001, time + dur);

        osc.connect(g);
        g.connect(this.musicGain);

        osc.start(time);
        osc.stop(time + dur + 0.02);
      }

      _playSnare(time, dur, amp)
      {
        // noise burst
        const noise =
          this._noiseBuffer();

        const src =
          this.ctx.createBufferSource();

        src.buffer =
          noise;

        const g =
          this.ctx.createGain();

        const bp =
          this.ctx.createBiquadFilter();

        bp.type =
          "bandpass";

        bp.frequency.setValueAtTime(2200, time);

        g.gain.setValueAtTime(0.0, time);
        g.gain.linearRampToValueAtTime(amp, time + 0.005);
        g.gain.exponentialRampToValueAtTime(0.001, time + dur);

        src.connect(bp);
        bp.connect(g);
        g.connect(this.musicGain);

        src.start(time);
        src.stop(time + dur + 0.02);
      }

      _noiseBuffer()
      {
        const len =
          Math.floor(this.ctx.sampleRate * 0.12);

        const buf =
          this.ctx.createBuffer(1, len, this.ctx.sampleRate);

        const data =
          buf.getChannelData(0);

        for (let i = 0; i < len; i++)
        {
          data[i] =
            (Math.random() * 2 - 1) * 0.6;
        }

        return buf;
      }

      // SFX
      sfxJump()
      {
        if (!this.ctx) return;
        if (!this.unlocked) return;
        if (this.muted) return;

        const time =
          this.ctx.currentTime;

        const osc =
          this.ctx.createOscillator();

        const g =
          this.ctx.createGain();

        osc.type =
          "triangle";

        osc.frequency.setValueAtTime(720, time);
        osc.frequency.exponentialRampToValueAtTime(980, time + 0.07);

        g.gain.setValueAtTime(0.0, time);
        g.gain.linearRampToValueAtTime(0.35, time + 0.006);
        g.gain.exponentialRampToValueAtTime(0.001, time + 0.085);

        osc.connect(g);
        g.connect(this.sfxGain);

        osc.start(time);
        osc.stop(time + 0.10);
      }

      sfxDeath()
      {
        if (!this.ctx) return;
        if (!this.unlocked) return;
        if (this.muted) return;

        const time =
          this.ctx.currentTime;

        // noise + downward pitch
        const noise =
          this._noiseBuffer();

        const src =
          this.ctx.createBufferSource();

        src.buffer =
          noise;

        const g =
          this.ctx.createGain();

        const lp =
          this.ctx.createBiquadFilter();

        lp.type =
          "lowpass";

        lp.frequency.setValueAtTime(1800, time);
        lp.frequency.exponentialRampToValueAtTime(220, time + 0.18);

        g.gain.setValueAtTime(0.0, time);
        g.gain.linearRampToValueAtTime(0.65, time + 0.006);
        g.gain.exponentialRampToValueAtTime(0.001, time + 0.22);

        src.connect(lp);
        lp.connect(g);
        g.connect(this.sfxGain);

        src.start(time);
        src.stop(time + 0.25);
      }

      sfxTick()
      {
        if (!this.ctx) return;
        if (!this.unlocked) return;
        if (this.muted) return;

        const time =
          this.ctx.currentTime;

        const osc =
          this.ctx.createOscillator();

        const g =
          this.ctx.createGain();

        osc.type =
          "sine";

        osc.frequency.setValueAtTime(1200, time);

        g.gain.setValueAtTime(0.0, time);
        g.gain.linearRampToValueAtTime(0.18, time + 0.002);
        g.gain.exponentialRampToValueAtTime(0.001, time + 0.05);

        osc.connect(g);
        g.connect(this.sfxGain);

        osc.start(time);
        osc.stop(time + 0.06);
      }
    }

    const audio =
      new AudioManager();

    /* =============================================================================
       Toast helper
       ============================================================================= */

    let toastTimer = 0;

    function showToast(msg)
    {
      toast.textContent =
        msg;

      toast.classList.remove("hidden");

      toastTimer =
        1.1;
    }
    // ===== Music tracks =====
    // Use "./static/..." for GitHub Pages style hosting,
    // or "/static/..." if your server mounts static at root.
    const MUSIC_TRACKS =
    [
        { id: "synth", name: "Built-in Synth (default)", type: "synth" },
        
        // Options for custom .mp3 files:
        { id: "1", name: "Mua Doi Cho Remix", type: "file", url: "./static/mua_doi_cho_remix.mp3" },
        // { id: "t2", name: "My Track 2", type: "file", url: "./static/track2.mp3" },

        { id: "off",   name: "Off",                     type: "off"   },
    ];

    function getTrackById(id)
    {
    return MUSIC_TRACKS.find(t => t.id === id) || MUSIC_TRACKS[0];
    }

    function initMusicMenu()
    {
    // populate <select>
    musicSelect.innerHTML = "";
    for (const t of MUSIC_TRACKS)
    {
        const opt = document.createElement("option");
        opt.value = t.id;
        opt.textContent = t.name;
        musicSelect.appendChild(opt);
    }

    // restore selection (robust even if you remove "synth")
    const saved = localStorage.getItem("neon_dash_track");
    const fallback = MUSIC_TRACKS[0]?.id || "off";

    const safeId =
      (saved && MUSIC_TRACKS.some(t => t.id === saved))
        ? saved
        : fallback;

    musicSelect.value = safeId;

    // apply to audio system
    audio.setMusicTrack(getTrackById(safeId));


    // apply to audio system
    audio.setMusicTrack(getTrackById(safeId));

    // on change
    musicSelect.addEventListener("change", () =>
    {
        const id = musicSelect.value;
        localStorage.setItem("neon_dash_track", id);
        audio.setMusicTrack(getTrackById(id));
        btnPreview.textContent = "Preview";
    });

    // preview button
    btnPreview.addEventListener("click", async () =>
    {
        await audio.unlock(); // required on mobile
        await audio.previewToggle();
        btnPreview.textContent = audio.isPreviewing() ? "Stop" : "Preview";
    });
    }

    initMusicMenu();

    /* =============================================================================
       Input handling
       ============================================================================= */

    const input =
    {
      jumpPressed:
        false,

      jumpHeld:
        false,

      restartPressed:
        false,

      mutePressed:
        false,

      anyPressed:
        false,

      pointerDown:
        false,
    };

    function consumeEdgeFlags()
    {
      input.jumpPressed = false;
      input.restartPressed = false;
      input.mutePressed = false;
      input.anyPressed = false;
    }

    function onKeyDown(e)
    {
      const k =
        e.key.toLowerCase();

      // prevent page scrolling on Space/Arrow
      if (k === " " || k === "arrowup" || k === "arrowdown")
      {
        e.preventDefault();
      }

      input.anyPressed = true;

      if (k === " " || k === "arrowup")
      {
        input.jumpPressed = true;
        input.jumpHeld = true;
      }

      if (k === "r")
      {
        input.restartPressed = true;
      }

      if (k === "m")
      {
        input.mutePressed = true;
      }
    }

    function onKeyUp(e)
    {
      const k =
        e.key.toLowerCase();

      if (k === " " || k === "arrowup")
      {
        input.jumpHeld = false;
      }
    }

    window.addEventListener("keydown", onKeyDown, { passive: false });
    window.addEventListener("keyup", onKeyUp, { passive: true });

    // Pointer / touch
    function onPointerDown(e)
    {
    // If MENU / GAMEOVER overlay is up, don't let canvas clicks start/jump.
    if (!overlay.classList.contains("hidden")) return;

    // Best effort unlock (helps if you start by clicking)
    audio.unlock();

    input.anyPressed = true;
    input.jumpPressed = true;
    input.pointerDown = true;
    }


    function onPointerUp(e)
    {
      input.pointerDown = false;
    }

    canvas.addEventListener("pointerdown", onPointerDown, { passive: true });
    window.addEventListener("pointerup", onPointerUp, { passive: true });

    // UI buttons
    btnStart.addEventListener("click", async () =>
    {
      await audio.unlock();
      startFromMenu();
    });

    btnRestart.addEventListener("click", async () =>
    {
      await audio.unlock();
      restartRun();
    });

    btnMute.addEventListener("click", async () =>
    {
      await audio.unlock();
      audio.toggleMute();
    });

    btnRestartTop.addEventListener("click", async () =>
    {
      await audio.unlock();
      restartRun();
    });

    /* =============================================================================
       Geometry / collision helpers
       ============================================================================= */

    function rectsOverlap(a, b)
    {
      return (
        a.x < b.x + b.w &&
        a.x + a.w > b.x &&
        a.y < b.y + b.h &&
        a.y + a.h > b.y
      );
    }

    function pointInTriangle(px, py, ax, ay, bx, by, cx, cy)
    {
      // Barycentric technique
      const v0x = cx - ax;
      const v0y = cy - ay;

      const v1x = bx - ax;
      const v1y = by - ay;

      const v2x = px - ax;
      const v2y = py - ay;

      const dot00 = v0x * v0x + v0y * v0y;
      const dot01 = v0x * v1x + v0y * v1y;
      const dot02 = v0x * v2x + v0y * v2y;
      const dot11 = v1x * v1x + v1y * v1y;
      const dot12 = v1x * v2x + v1y * v2y;

      const invDen =
        1 / (dot00 * dot11 - dot01 * dot01);

      const u =
        (dot11 * dot02 - dot01 * dot12) * invDen;

      const v =
        (dot00 * dot12 - dot01 * dot02) * invDen;

      return (
        u >= 0 &&
        v >= 0 &&
        u + v <= 1
      );
    }

    function segmentsIntersect(ax, ay, bx, by, cx, cy, dx, dy)
    {
      // robust segment intersection via orientation
      function orient(px, py, qx, qy, rx, ry)
      {
        return (qy - py) * (rx - qx) - (qx - px) * (ry - qy);
      }

      function onSeg(px, py, qx, qy, rx, ry)
      {
        return (
          Math.min(px, rx) <= qx && qx <= Math.max(px, rx) &&
          Math.min(py, ry) <= qy && qy <= Math.max(py, ry)
        );
      }

      const o1 = orient(ax, ay, bx, by, cx, cy);
      const o2 = orient(ax, ay, bx, by, dx, dy);
      const o3 = orient(cx, cy, dx, dy, ax, ay);
      const o4 = orient(cx, cy, dx, dy, bx, by);

      if (o1 === 0 && onSeg(ax, ay, cx, cy, bx, by)) return true;
      if (o2 === 0 && onSeg(ax, ay, dx, dy, bx, by)) return true;
      if (o3 === 0 && onSeg(cx, cy, ax, ay, dx, dy)) return true;
      if (o4 === 0 && onSeg(cx, cy, bx, by, dx, dy)) return true;

      return (o1 > 0) !== (o2 > 0) && (o3 > 0) !== (o4 > 0);
    }

    function rectIntersectsTriangle(rect, tri)
    {
      // tri = { ax,ay,bx,by,cx,cy }
      // 1) quick AABB check for triangle vs rect
      const minX =
        Math.min(tri.ax, tri.bx, tri.cx);

      const maxX =
        Math.max(tri.ax, tri.bx, tri.cx);

      const minY =
        Math.min(tri.ay, tri.by, tri.cy);

      const maxY =
        Math.max(tri.ay, tri.by, tri.cy);

      const triAabb =
      {
        x: minX,
        y: minY,
        w: maxX - minX,
        h: maxY - minY,
      };

      if (!rectsOverlap(rect, triAabb))
      {
        return false;
      }

      // 2) rect corners inside triangle
      const corners =
      [
        [rect.x, rect.y],
        [rect.x + rect.w, rect.y],
        [rect.x + rect.w, rect.y + rect.h],
        [rect.x, rect.y + rect.h],
      ];

      for (let i = 0; i < corners.length; i++)
      {
        const [px, py] = corners[i];

        if (pointInTriangle(px, py, tri.ax, tri.ay, tri.bx, tri.by, tri.cx, tri.cy))
        {
          return true;
        }
      }

      // 3) triangle vertices inside rect
      function pointInRect(px, py, r)
      {
        return (
          px >= r.x &&
          px <= r.x + r.w &&
          py >= r.y &&
          py <= r.y + r.h
        );
      }

      if (pointInRect(tri.ax, tri.ay, rect)) return true;
      if (pointInRect(tri.bx, tri.by, rect)) return true;
      if (pointInRect(tri.cx, tri.cy, rect)) return true;

      // 4) edge intersections (rect edges vs tri edges)
      const re =
      [
        // rect edges
        [rect.x, rect.y, rect.x + rect.w, rect.y],
        [rect.x + rect.w, rect.y, rect.x + rect.w, rect.y + rect.h],
        [rect.x + rect.w, rect.y + rect.h, rect.x, rect.y + rect.h],
        [rect.x, rect.y + rect.h, rect.x, rect.y],
      ];

      const te =
      [
        [tri.ax, tri.ay, tri.bx, tri.by],
        [tri.bx, tri.by, tri.cx, tri.cy],
        [tri.cx, tri.cy, tri.ax, tri.ay],
      ];

      for (let i = 0; i < re.length; i++)
      {
        for (let j = 0; j < te.length; j++)
        {
          if (segmentsIntersect(
            re[i][0], re[i][1], re[i][2], re[i][3],
            te[j][0], te[j][1], te[j][2], te[j][3]
          ))
          {
            return true;
          }
        }
      }

      return false;
    }

    /* =============================================================================
       Particles
       ============================================================================= */

    class Particle
    {
      constructor(x, y, vx, vy, life, size, kind)
      {
        this.x = x;
        this.y = y;

        this.vx = vx;
        this.vy = vy;

        this.life = life;
        this.lifeMax = life;

        this.size = size;

        this.kind = kind; // "trail" | "boom" | "spark"
        this.rot = rand(0, TAU);
        this.spin = rand(-8, 8);
      }

      update(dt)
      {
        this.life -= dt;

        this.x += this.vx * dt;
        this.y += this.vy * dt;

        // slight drag
        this.vx *= Math.pow(0.40, dt);
        this.vy *= Math.pow(0.40, dt);

        // gravity for some kinds
        if (this.kind !== "trail")
        {
          this.vy += 900 * dt;
        }

        this.rot += this.spin * dt;
      }

      draw(g, pulse)
      {
        const t =
          clamp(this.life / this.lifeMax, 0, 1);

        const a =
          t * (this.kind === "trail" ? 0.35 : 0.9);

        g.save();

        g.globalAlpha =
          a;

        g.translate(this.x, this.y);
        g.rotate(this.rot);

        const s =
          this.size * (0.65 + 0.55 * (1 - t));

        if (this.kind === "trail")
        {
          g.fillStyle =
            `rgba(125, 249, 255, ${0.8 * a})`;

          g.shadowBlur =
            18 + 10 * pulse;

          g.shadowColor =
            "rgba(125, 249, 255, 0.6)";

          g.fillRect(-s * 0.5, -s * 0.5, s, s);
        }
        else
        {
          g.fillStyle =
            `rgba(255, 77, 255, ${0.85 * a})`;

          g.shadowBlur =
            22 + 18 * pulse;

          g.shadowColor =
            "rgba(255, 77, 255, 0.7)";

          g.fillRect(-s * 0.5, -s * 0.5, s, s);
        }

        g.restore();
      }
    }

    /* =============================================================================
       Obstacles
       ============================================================================= */

    class Obstacle
    {
      constructor(type, worldX, y, w, h, data)
      {
        this.type =
          type;   // "spike" | "block"

        this.worldX =
          worldX;

        this.y =
          y;

        this.w =
          w;

        this.h =
          h;

        this.data =
          data || {};
      }

      getScreenX(worldDist)
      {
        return (this.worldX - worldDist) + playerX;
      }

      draw(g, worldDist, pulse)
      {
        const sx =
          this.getScreenX(worldDist);

        if (sx + this.w < -200) return;
        if (sx > W + 200) return;

        if (this.type === "block")
        {
          // neon block
          g.save();

          const x = sx;
          const y = this.y;

          g.shadowBlur =
            18 + 12 * pulse;

          g.shadowColor =
            "rgba(124, 252, 154, 0.65)";

          // fill
          g.fillStyle =
            "rgba(10, 255, 150, 0.14)";

          g.fillRect(x, y, this.w, this.h);

          // outline
          g.lineWidth =
            2;

          g.strokeStyle =
            "rgba(124, 252, 154, 0.85)";

          g.strokeRect(x + 1, y + 1, this.w - 2, this.h - 2);

          // inner highlight
          g.lineWidth =
            1;

          g.strokeStyle =
            "rgba(255, 255, 255, 0.22)";

          g.strokeRect(x + 4, y + 4, this.w - 8, this.h - 8);

          g.restore();
        }
        else if (this.type === "spike")
        {
          // neon spike triangle
          const x = sx;
          const y = this.y;

          const ax = x;
          const ay = y + this.h;

          const bx = x + this.w * 0.5;
          const by = y;

          const cx = x + this.w;
          const cy = y + this.h;

          g.save();

          g.shadowBlur =
            18 + 14 * pulse;

          g.shadowColor =
            "rgba(255, 77, 255, 0.7)";

          g.beginPath();
          g.moveTo(ax, ay);
          g.lineTo(bx, by);
          g.lineTo(cx, cy);
          g.closePath();

          g.fillStyle =
            "rgba(255, 77, 255, 0.15)";

          g.fill();

          g.lineWidth =
            2;

          g.strokeStyle =
            "rgba(255, 77, 255, 0.9)";

          g.stroke();

          // tiny inner glow line
          g.lineWidth =
            1;

          g.strokeStyle =
            "rgba(255, 255, 255, 0.18)";

          g.beginPath();
          g.moveTo(ax + 4, ay - 2);
          g.lineTo(bx, by + 6);
          g.lineTo(cx - 4, cy - 2);
          g.stroke();

          g.restore();
        }
      }

      getCollisionShape(worldDist)
      {
        const sx =
          this.getScreenX(worldDist);

        if (this.type === "block")
        {
          return {
            kind: "rect",
            rect:
            {
              x: sx,
              y: this.y,
              w: this.w,
              h: this.h,
            }
          };
        }

        // spike triangle
        const tri =
        {
          ax: sx,
          ay: this.y + this.h,

          bx: sx + this.w * 0.5,
          by: this.y,

          cx: sx + this.w,
          cy: this.y + this.h,
        };

        // Optional: a smaller “fairness” rect to early-reject
        const inset =
          0.16;

        const fx =
          sx + this.w * inset;

        const fy =
          this.y + this.h * inset;

        const fw =
          this.w * (1 - inset * 2);

        const fh =
          this.h * (1 - inset);

        return {
          kind: "tri",
          tri,
          fairnessRect:
          {
            x: fx,
            y: fy,
            w: fw,
            h: fh,
          },
        };
      }
    }

    /* =============================================================================
       Player
       ============================================================================= */

    class Player
    {
      constructor()
      {
        this.reset();
      }

      reset()
      {
        this.size =
          CONFIG.playerSize;

        this.x =
          playerX;

        this.y =
          groundY - this.size;

        this.vy =
          0;

        this.onGround =
          true;

        this.coyote =
          0;

        this.jumpBuf =
          0;

        this.rot =
          0;

        this.trailAcc =
          0;

        this.dead =
          false;

        this.squish =
          0;

        this.squishV =
          0;
      }

      getRect()
      {
        // Fair AABB collision: treat as axis-aligned square (like classic GD)
        return {
          x: this.x,
          y: this.y,
          w: this.size,
          h: this.size,
        };
      }

      tryJump()
      {
        if (this.dead) return false;

        // jump allowed if on ground or within coyote time
        if (this.onGround || this.coyote > 0)
        {
          this.vy =
            -CONFIG.jumpSpeed;

          this.onGround =
            false;

          this.coyote =
            0;

          // squish effect
          this.squishV =
            -7.5;

          audio.sfxJump();

          return true;
        }

        return false;
      }

      update(dt, worldSpeed)
      {
        if (this.dead) return;

        // Update timers
        if (!this.onGround)
        {
          this.coyote =
            Math.max(0, this.coyote - dt);
        }

        this.jumpBuf =
          Math.max(0, this.jumpBuf - dt);

        // Input → buffer jump
        if (input.jumpPressed)
        {
          this.jumpBuf =
            CONFIG.jumpBuffer;
        }

        // Apply buffered jump if we can
        if (this.jumpBuf > 0)
        {
          if (this.onGround || this.coyote > 0)
          {
            const did =
              this.tryJump();

            if (did)
            {
              this.jumpBuf = 0;
            }
          }
        }

        // Physics
        this.vy +=
          CONFIG.gravity * dt;

        this.vy =
          Math.min(this.vy, CONFIG.maxFallSpeed);

        this.y +=
          this.vy * dt;

        // Ground collision
        const groundTop =
          groundY - this.size;

        if (this.y >= groundTop)
        {
          // landing
          if (!this.onGround)
          {
            // snap rotation toward nearest 90 deg
            // and do a small landing squish
            this.squishV =
              7.0;
          }

          this.y =
            groundTop;

          this.vy =
            0;

          this.onGround =
            true;

          this.coyote =
            CONFIG.coyoteTime;
        }
        else
        {
          if (this.onGround)
          {
            // leaving ground → enable coyote time
            this.coyote =
              CONFIG.coyoteTime;
          }

          this.onGround =
            false;
        }

        // Rotation (Geometry Dash style)
        if (!this.onGround)
        {
          const rotSpeed =
            CONFIG.rotPerSecond * (worldSpeed / CONFIG.baseSpeed);

          this.rot +=
            rotSpeed * dt;
        }
        else
        {
          // Smoothly snap rotation to nearest quarter-turn when grounded
          const snap =
            Math.round(this.rot / (Math.PI / 2)) * (Math.PI / 2);

          const diff =
            snap - this.rot;

          this.rot +=
            diff * clamp(CONFIG.rotSnapStrength * dt, 0, 1);
        }

        // Squish animation
        this.squishV +=
          (-this.squish * 28) * dt;

        this.squishV *=
          Math.pow(0.06, dt);

        this.squish +=
          this.squishV * dt;

        this.squish =
          clamp(this.squish, -0.22, 0.22);

        // Trail particles
        this.trailAcc +=
          CONFIG.trailRate * dt;

        while (this.trailAcc >= 1)
        {
          this.trailAcc -= 1;

          if (!this.onGround)
          {
            spawnTrailParticle(this.x + this.size * 0.15, this.y + this.size * 0.5);
          }
          else
          {
            // subtle trail even on ground (smaller)
            if (Math.random() < 0.25)
            {
              spawnTrailParticle(this.x + this.size * 0.15, this.y + this.size * 0.65, true);
            }
          }
        }
      }

      draw(g, pulse)
      {
        const cx =
          this.x + this.size * 0.5;

        const cy =
          this.y + this.size * 0.5;

        g.save();

        g.translate(cx, cy);
        g.rotate(this.rot);

        // squish scale
        const sx =
          1 + this.squish * 0.9;

        const sy =
          1 - this.squish * 0.9;

        g.scale(sx, sy);

        // main cube
        g.shadowBlur =
          22 + 14 * pulse;

        g.shadowColor =
          "rgba(125, 249, 255, 0.75)";

        g.fillStyle =
          "rgba(125, 249, 255, 0.12)";

        g.fillRect(-this.size * 0.5, -this.size * 0.5, this.size, this.size);

        // outline
        g.lineWidth =
          2;

        g.strokeStyle =
          "rgba(125, 249, 255, 0.95)";

        g.strokeRect(-this.size * 0.5 + 1, -this.size * 0.5 + 1, this.size - 2, this.size - 2);

        // inner crisp edge
        g.lineWidth =
          1;

        g.strokeStyle =
          "rgba(255, 255, 255, 0.18)";

        g.strokeRect(-this.size * 0.5 + 5, -this.size * 0.5 + 5, this.size - 10, this.size - 10);

        g.restore();
      }
    }

    /* =============================================================================
       Background — parallax layers
       =============================================================================
       Strategy:
       - Use worldDistance as time-based scroll reference
       - Multiple layers with different parallax factors
       - Add moving grid + occasional neon “blocks” for vibe
       - Beat pulse factor modulates glow/brightness
       ============================================================================= */

    const stars =
      [];

    function initStars()
    {
      stars.length = 0;

      const count =
        140;

      for (let i = 0; i < count; i++)
      {
        stars.push(
          {
            wx: rand(-600, 3600),
            y: rand(40, H * 0.65),
            r: rand(0.8, 2.4),
            tw: rand(0.3, 1.2),
          }
        );
      }
    }

    initStars();

    function drawBackground(g, worldDist, pulse)
    {
      // Base gradient fill
      const grad =
        g.createLinearGradient(0, 0, 0, H);

      grad.addColorStop(0.0, "#070717");
      grad.addColorStop(0.55, "#08081a");
      grad.addColorStop(1.0, "#04040e");

      g.fillStyle = grad;
      g.fillRect(0, 0, W, H);

      // Far stars
      g.save();

      g.globalAlpha =
        0.95;

      for (let i = 0; i < stars.length; i++)
      {
        const s = stars[i];

        // Parallax factor
        const px =
          ((s.wx - worldDist * 0.05) % 4200 + 4200) % 4200;

        const x =
          px - 600;

        const tw =
          0.6 + 0.4 * Math.sin((worldTime * 2.2) + s.tw * 10);

        g.globalAlpha =
          0.22 * tw;

        g.beginPath();
        g.arc(x, s.y, s.r, 0, TAU);

        g.fillStyle =
          `rgba(255, 255, 255, ${0.55 + 0.25 * pulse})`;

        g.fill();
      }

      g.restore();

      // Mid “mountain” silhouettes (neon haze)
      drawNeonHills(g, worldDist, pulse);

      // Near grid overlay
      drawGrid(g, worldDist, pulse);

      // Ground haze
      g.save();

      g.globalAlpha =
        0.55;

      g.fillStyle =
        "rgba(125, 249, 255, 0.05)";

      g.fillRect(0, groundY, W, H - groundY);

      g.restore();
    }

    function drawNeonHills(g, worldDist, pulse)
    {
      const baseY =
        groundY - H * 0.28;

      const amp =
        26 + 10 * pulse;

      const period =
        340;

      // far layer
      g.save();

      g.globalAlpha =
        0.65;

      g.shadowBlur =
        18 + 18 * pulse;

      g.shadowColor =
        "rgba(255, 77, 255, 0.25)";

      g.beginPath();
      g.moveTo(0, groundY);

      for (let x = 0; x <= W; x += 18)
      {
        const wx =
          worldDist * 0.12 + x;

        const y =
          baseY +
          Math.sin(wx / period) * amp +
          Math.sin(wx / (period * 0.55)) * (amp * 0.35);

        g.lineTo(x, y);
      }

      g.lineTo(W, groundY);
      g.closePath();

      g.fillStyle =
        "rgba(255, 77, 255, 0.06)";

      g.fill();

      g.restore();

      // mid layer
      g.save();

      g.globalAlpha =
        0.85;

      g.shadowBlur =
        18 + 16 * pulse;

      g.shadowColor =
        "rgba(125, 249, 255, 0.25)";

      g.beginPath();
      g.moveTo(0, groundY);

      for (let x = 0; x <= W; x += 16)
      {
        const wx =
          worldDist * 0.18 + x;

        const y =
          baseY + 70 +
          Math.sin(wx / (period * 0.85)) * (amp * 0.9) +
          Math.sin(wx / (period * 0.42)) * (amp * 0.24);

        g.lineTo(x, y);
      }

      g.lineTo(W, groundY);
      g.closePath();

      g.fillStyle =
        "rgba(125, 249, 255, 0.045)";

      g.fill();

      g.restore();
    }

    function drawGrid(g, worldDist, pulse)
    {
      const spacing =
        46;

      const off =
        (worldDist * 0.65) % spacing;

      g.save();

      g.globalAlpha =
        0.25 + 0.08 * pulse;

      g.lineWidth =
        1;

      g.strokeStyle =
        "rgba(255, 255, 255, 0.10)";

      // vertical lines
      g.beginPath();

      for (let x = -off; x <= W + spacing; x += spacing)
      {
        g.moveTo(x, 0);
        g.lineTo(x, groundY);
      }

      // horizontal lines (lighter)
      for (let y = 40; y <= groundY; y += spacing)
      {
        g.moveTo(0, y);
        g.lineTo(W, y);
      }

      g.stroke();

      // occasional neon rectangles
      g.globalAlpha =
        0.08 + 0.06 * pulse;

      g.fillStyle =
        "rgba(255, 77, 255, 0.25)";

      const n =
        6;

      for (let i = 0; i < n; i++)
      {
        const x =
          ((i * 370) - (worldDist * 0.25) % 370) % (W + 370) - 90;

        const y =
          60 + (i * 43) % Math.max(120, groundY - 140);

        g.fillRect(x, y, 58, 10);
      }

      g.restore();
    }

    function drawGround(g, worldDist, pulse)
    {
      // ground line with glow
      g.save();

      g.shadowBlur =
        22 + 14 * pulse;

      g.shadowColor =
        "rgba(255, 211, 107, 0.55)";

      g.strokeStyle =
        "rgba(255, 211, 107, 0.95)";

      g.lineWidth =
        3;

      g.beginPath();
      g.moveTo(0, groundY);
      g.lineTo(W, groundY);
      g.stroke();

      // subtle texture “ticks”
      g.shadowBlur = 0;

      g.globalAlpha =
        0.28;

      g.strokeStyle =
        "rgba(255, 255, 255, 0.12)";

      g.lineWidth =
        1;

      const spacing =
        24;

      const off =
        (worldDist * 0.9) % spacing;

      g.beginPath();

      for (let x = -off; x <= W + spacing; x += spacing)
      {
        g.moveTo(x, groundY + 2);
        g.lineTo(x + 10, groundY + 2);
      }

      g.stroke();

      g.restore();
    }

    /* =============================================================================
       Obstacle generator (procedural + fair)
       =============================================================================
       We generate “patterns” rather than totally random singles so it feels more
       like a real GD level:
       - single spike
       - double spike
       - triple spike
       - block
       - block + spike
       - spike + block
       All patterns are spaced with a gap that depends on difficulty & speed.
       ============================================================================= */

    class PatternGenerator
    {
      constructor()
      {
        this.reset();
      }

      reset()
      {
        this.spawnCursor =
          0; // world X where next pattern begins

        this.lastPattern =
          "";
      }

      seedInitial(worldDist)
      {
        this.spawnCursor =
          worldDist + 600;
      }

      getDifficulty01(speed)
      {
        return clamp(
          (speed - CONFIG.baseSpeed) / (CONFIG.maxSpeed - CONFIG.baseSpeed),
          0,
          1
        );
      }

      spawnUntil(obstacles, worldDist, speed)
      {
        const limit =
          worldDist + CONFIG.spawnAhead;

        while (this.spawnCursor < limit)
        {
          this.spawnPattern(obstacles, speed);
        }
      }

      spawnPattern(obstacles, speed)
      {
        const diff =
          this.getDifficulty01(speed);

        const gap =
          lerp(CONFIG.maxGap, CONFIG.minGap, diff) + rand(-60, 60);

        const choice =
          this.choosePattern(diff);

        const baseY =
          groundY;

        let length =
          0;

        if (choice === "S1")
        {
          const w = CONFIG.spikeWidth;
          const h = CONFIG.spikeHeight;

          obstacles.push(
            new Obstacle(
              "spike",
              this.spawnCursor,
              baseY - h,
              w,
              h
            )
          );

          length = w;
        }
        else if (choice === "S2")
        {
          const w = CONFIG.spikeWidth;
          const h = CONFIG.spikeHeight;

          obstacles.push(new Obstacle("spike", this.spawnCursor, baseY - h, w, h));
          obstacles.push(new Obstacle("spike", this.spawnCursor + w * 0.95, baseY - h, w, h));

          length = w * 2;
        }
        else if (choice === "S3")
        {
          const w = CONFIG.spikeWidth;
          const h = CONFIG.spikeHeight;

          obstacles.push(new Obstacle("spike", this.spawnCursor, baseY - h, w, h));
          obstacles.push(new Obstacle("spike", this.spawnCursor + w * 0.95, baseY - h, w, h));
          obstacles.push(new Obstacle("spike", this.spawnCursor + w * 1.90, baseY - h, w, h));

          length = w * 3;
        }
        else if (choice === "B1")
        {
          const size =
            randInt(CONFIG.blockMin, CONFIG.blockMax);

          obstacles.push(
            new Obstacle(
              "block",
              this.spawnCursor,
              baseY - size,
              size,
              size
            )
          );

          length = size;
        }
        else if (choice === "BS")
        {
          const size =
            randInt(CONFIG.blockMin, CONFIG.blockMax);

          const w = CONFIG.spikeWidth;
          const h = CONFIG.spikeHeight;

          obstacles.push(
            new Obstacle(
              "block",
              this.spawnCursor,
              baseY - size,
              size,
              size
            )
          );

          obstacles.push(
            new Obstacle(
              "spike",
              this.spawnCursor + size + lerp(70, 44, diff),
              baseY - h,
              w,
              h
            )
          );

          length =
            size + 140;
        }
        else if (choice === "SB")
        {
          const w = CONFIG.spikeWidth;
          const h = CONFIG.spikeHeight;

          const size =
            randInt(CONFIG.blockMin, CONFIG.blockMax);

          obstacles.push(
            new Obstacle(
              "spike",
              this.spawnCursor,
              baseY - h,
              w,
              h
            )
          );

          obstacles.push(
            new Obstacle(
              "block",
              this.spawnCursor + w + lerp(80, 50, diff),
              baseY - size,
              size,
              size
            )
          );

          length =
            w + 160;
        }
        else
        {
          // fallback
          const w = CONFIG.spikeWidth;
          const h = CONFIG.spikeHeight;

          obstacles.push(
            new Obstacle(
              "spike",
              this.spawnCursor,
              baseY - h,
              w,
              h
            )
          );

          length = w;
        }

        // Push spawn cursor forward
        this.spawnCursor +=
          length + gap;

        this.lastPattern =
          choice;
      }

      choosePattern(diff)
      {
        // Easy → mostly single spikes and blocks
        // Hard → more doubles/triples and mixed patterns
        const r =
          Math.random();

        if (diff < 0.25)
        {
          if (r < 0.45) return "S1";
          if (r < 0.75) return "B1";
          if (r < 0.88) return "SB";
          return "BS";
        }

        if (diff < 0.60)
        {
          if (r < 0.28) return "S1";
          if (r < 0.52) return "S2";
          if (r < 0.72) return "B1";
          if (r < 0.86) return "SB";
          return "BS";
        }

        // late game
        if (r < 0.18) return "S1";
        if (r < 0.42) return "S2";
        if (r < 0.62) return "S3";
        if (r < 0.75) return "B1";
        if (r < 0.88) return "SB";
        return "BS";
      }
    }

    /* =============================================================================
       Game state
       ============================================================================= */

    const STATE =
    {
      MENU: "MENU",
      PLAYING: "PLAYING",
      GAMEOVER: "GAMEOVER",
    };

    let state =
      STATE.MENU;

    const player =
      new Player();

    const obstacles =
      [];

    const particles =
      [];

    const generator =
      new PatternGenerator();

    let worldDist =
      0;

    let worldSpeed =
      CONFIG.baseSpeed;

    let runTime =
      0;

    let score =
      0;

    let bestScore =
      0;

    let milestone =
      0;

    let shakeT =
      0;

    let shakeMag =
      0;

    let worldTime =
      0;

    // beat phase (for pulse)
    let beatPhase =
      0;

    // fixed timestep accumulator
    let lastFrameT =
      0;

    let accumulator =
      0;

    /* =============================================================================
       Storage
       ============================================================================= */

    function loadBest()
    {
      const v =
        localStorage.getItem("neon_dash_best");

      bestScore =
        v ? parseInt(v, 10) : 0;

      if (!Number.isFinite(bestScore)) bestScore = 0;

      uiBest.textContent =
        bestScore.toString();
    }

    function saveBest()
    {
      localStorage.setItem("neon_dash_best", String(bestScore));
      uiBest.textContent = bestScore.toString();
    }

    loadBest();

    /* =============================================================================
       Particle spawners
       ============================================================================= */

    function spawnTrailParticle(x, y, small)
    {
      const p =
        new Particle(
          x + rand(-2, 2),
          y + rand(-2, 2),
          rand(-90, -220),
          rand(-30, 80),
          small ? rand(0.14, 0.22) : rand(0.18, 0.32),
          small ? rand(6, 10) : rand(8, 13),
          "trail"
        );

      particles.push(p);
    }

    function spawnDeathExplosion(x, y)
    {
      for (let i = 0; i < CONFIG.deathParticles; i++)
      {
        const a =
          rand(0, TAU);

        const sp =
          rand(220, 1200);

        const vx =
          Math.cos(a) * sp;

        const vy =
          Math.sin(a) * sp - rand(0, 260);

        particles.push(
          new Particle(
            x + rand(-6, 6),
            y + rand(-6, 6),
            vx,
            vy,
            rand(0.35, 0.72),
            rand(8, 16),
            "boom"
          )
        );
      }
    }

    /* =============================================================================
       State transitions
       ============================================================================= */

    function setState(next)
    {
      state = next;

      uiState.textContent =
        next;

      if (next === STATE.MENU)
      {
        overlay.classList.remove("hidden");

        btnStart.style.display =
          "inline-block";

        btnRestart.style.display =
          "none";

        panelTitle.textContent =
          "NEON DASH";

        panelSubtitle.textContent =
          "Geometry-Dash-style rhythm runner";

        panelText.innerHTML =
          "Press <b>Start</b> to start.<br/>Time your jumps. One hit = boom.";
        musicPanel.style.display = "block";
        btnPreview.textContent = "Preview";

        audio.stopMusic();
      }
      else if (next === STATE.PLAYING)
      {
        overlay.classList.add("hidden");
        audio.startMusic();
        musicPanel.style.display = "none";
      }
    else if (next === STATE.GAMEOVER)
    {
        overlay.classList.remove("hidden");

        btnStart.style.display = "none";
        btnRestart.style.display = "inline-block";

        panelTitle.textContent = "GAME OVER";
        panelSubtitle.textContent = "Press R / Tap to restart";

        panelText.innerHTML =
            `Score: <b>${Math.floor(score)}</b><br/>Best: <b>${bestScore}</b><br/>Press <b>R</b> or <b>Tap</b> to restart.`;

        // show music settings on defeat page too
        musicPanel.style.display = "block";
        btnPreview.textContent = "Preview";

        audio.stopMusic();
    }
    }

    function startFromMenu()
    {
      if (state !== STATE.MENU) return;

      restartRun();
      setState(STATE.PLAYING);
    }

    function restartRun()
    {
      // reset everything
      obstacles.length = 0;
      particles.length = 0;

      player.reset();

      worldDist = 0;
      runTime = 0;

      worldSpeed = CONFIG.baseSpeed;

      score = 0;
      milestone = 0;

      shakeT = 0;
      shakeMag = 0;

      generator.reset();
      generator.seedInitial(worldDist);

      // pre-spawn enough obstacles so it feels continuous
      generator.spawnUntil(obstacles, worldDist, worldSpeed);

      setState(STATE.PLAYING);
    }

    // pointer unlock audio (DO NOT auto-start the game)
    window.addEventListener("pointerdown", async () =>
    {
      await audio.unlock();
    }, { passive: true });

    function killPlayer()
    {
      if (state !== STATE.PLAYING) return;
      if (player.dead) return;

      player.dead = true;

      // explosion
      spawnDeathExplosion(
        player.x + player.size * 0.5,
        player.y + player.size * 0.5
      );

      // screen shake
      shakeT =
        CONFIG.shakeTime;

      shakeMag =
        CONFIG.shakeMag;

      audio.sfxDeath();

      // best score check
      const final =
        Math.floor(score);

      if (final > bestScore)
      {
        bestScore = final;
        saveBest();
      }

      setState(STATE.GAMEOVER);
    }

    /* =============================================================================
       Main update (fixed timestep)
       ============================================================================= */

    function update(dt)
    {
      worldTime += dt;

      // UI timers
      if (toastTimer > 0)
      {
        toastTimer -= dt;

        if (toastTimer <= 0)
        {
          toast.classList.add("hidden");
        }
      }

      // Beat pulse phase
      beatPhase +=
        dt * (CONFIG.bpm / 60);

      // keep in a manageable range
      if (beatPhase > 1e6) beatPhase -= 1e6;

      // pulsing factor for visuals (0..1)
      // Use a smooth “thump” shape.
      // phaseFrac is [0..1)
      const phaseFrac =
        beatPhase % 1;

      // We'll compute pulse in render; but audio uses scheduling too.
      audio.tickMusic();

      if (state !== STATE.PLAYING)
      {
        // still update particles for polish
        for (let i = particles.length - 1; i >= 0; i--)
        {
          particles[i].update(dt);
          if (particles[i].life <= 0) particles.splice(i, 1);
        }

        // allow tap to restart after deathF
        if (state === STATE.GAMEOVER)
        {
          if (input.jumpPressed || input.restartPressed)
          {
            restartRun();
          }
        }

        // allow start from menu via jump
        if (state === STATE.MENU)
        {
          if (input.jumpPressed)
          {
            startFromMenu();
          }
        }

        return;
      }

      // Difficulty ramp: speed increases slowly with run time
      runTime += dt;

      worldSpeed +=
        CONFIG.speedRampPerSec * dt;

      worldSpeed =
        Math.min(worldSpeed, CONFIG.maxSpeed);

      // score increases with distance
      score +=
        worldSpeed * dt * CONFIG.scorePerUnit;

      // milestone tick every 100 points
      const ms =
        Math.floor(score / 100);

      if (ms > milestone)
      {
        milestone = ms;
        audio.sfxTick();
      }

      // advance world distance
      worldDist +=
        worldSpeed * dt;

      // player physics + input
      player.update(dt, worldSpeed);

      // spawn obstacles ahead
      generator.spawnUntil(obstacles, worldDist, worldSpeed);

      // collision checks
      const pr =
        player.getRect();

      // Slightly shrink player rect for fairness
      const inset =
        6;

      const prFair =
      {
        x: pr.x + inset,
        y: pr.y + inset,
        w: pr.w - inset * 2,
        h: pr.h - inset * 2,
      };

      for (let i = 0; i < obstacles.length; i++)
      {
        const o =
          obstacles[i];

        const shape =
          o.getCollisionShape(worldDist);

        if (shape.kind === "rect")
        {
          if (rectsOverlap(prFair, shape.rect))
          {
            killPlayer();
            break;
          }
        }
        else if (shape.kind === "tri")
        {
          // early reject using fairness rect for spike
          if (!rectsOverlap(prFair, shape.fairnessRect))
          {
            continue;
          }

          if (rectIntersectsTriangle(prFair, shape.tri))
          {
            killPlayer();
            break;
          }
        }
      }

      // remove far-behind obstacles (world coords)
      while (obstacles.length > 0)
      {
        const o0 =
          obstacles[0];

        const sx =
          o0.getScreenX(worldDist);

        if (sx + o0.w < -320)
        {
          obstacles.shift();
        }
        else
        {
          break;
        }
      }

      // screen shake decay
      if (shakeT > 0)
      {
        shakeT -= dt;

        if (shakeT < 0) shakeT = 0;
      }

      // update particles
      for (let i = particles.length - 1; i >= 0; i--)
      {
        particles[i].update(dt);
        if (particles[i].life <= 0) particles.splice(i, 1);
      }
    }

    /* =============================================================================
       Render
       ============================================================================= */

    function computePulse()
    {
      const f =
        beatPhase % 1;

      // pulse shape: quick rise, slow fall
      const thump =
        Math.exp(-f * 6.5) * Math.sin(f * Math.PI);

      return clamp(thump * 2.0, 0, 1);
    }

    function render()
    {
      const pulse =
        computePulse();

      // clear
      ctx.clearRect(0, 0, W, H);

      // screen shake transform
      let sx = 0;
      let sy = 0;

      if (shakeT > 0)
      {
        const t =
          shakeT / CONFIG.shakeTime;

        const mag =
          shakeMag * t;

        sx =
          rand(-mag, mag);

        sy =
          rand(-mag, mag);
      }

      ctx.save();
      ctx.translate(sx, sy);

      // background layers
      drawBackground(ctx, worldDist, pulse);

      // obstacles
      for (let i = 0; i < obstacles.length; i++)
      {
        obstacles[i].draw(ctx, worldDist, pulse);
      }

      // ground
      drawGround(ctx, worldDist, pulse);

      // particles (behind player looks better)
      for (let i = 0; i < particles.length; i++)
      {
        particles[i].draw(ctx, pulse);
      }

      // player
      player.draw(ctx, pulse);

      ctx.restore();

      // UI text updates
      uiScore.textContent =
        Math.floor(score).toString();

      uiBest.textContent =
        bestScore.toString();

      const speedMult =
        worldSpeed / CONFIG.baseSpeed;

      uiSpeed.textContent =
        speedMult.toFixed(2) + "x";
    }

    /* =============================================================================
       Main loop (requestAnimationFrame + fixed timestep)
       ============================================================================= */

    function frame(tMs)
    {
      const t =
        tMs * 0.001;

      if (!lastFrameT)
      {
        lastFrameT = t;
      }

      let dt =
        t - lastFrameT;

      lastFrameT = t;

      dt =
        clamp(dt, 0, CONFIG.maxFrameDt);

      accumulator += dt;

      while (accumulator >= CONFIG.fixedDt)
      {
        update(CONFIG.fixedDt);
        accumulator -= CONFIG.fixedDt;

        // consume edge inputs per step for consistency
        consumeEdgeFlags();
      }

      // render once per raf
      render();

      requestAnimationFrame(frame);
    }

    requestAnimationFrame(frame);

    /* =============================================================================
       Button / key driven actions (outside fixed loop)
       ============================================================================= */

    // We also listen for mute/restart edges in real-time.
    // This keeps UI snappy even if fixed loop is “busy”.
    window.addEventListener("keydown", async (e) =>
    {
      const k = e.key.toLowerCase();

      if (k === "m")
      {
        await audio.unlock();
        audio.toggleMute();
      }

      if (k === "r")
      {
        await audio.unlock();
        // optional: only allow restart from GAMEOVER/PLAYING
        if (state === STATE.GAMEOVER || state === STATE.PLAYING) restartRun();
      }
    }, { passive: false });

    // initial state
    setState(STATE.MENU);

    /* =============================================================================
       Extra: keep stars refreshed if resizing changes H
       ============================================================================= */

    window.addEventListener("resize", () =>
    {
      initStars();
    });

    /* =============================================================================
       ============================================================================

       TUNING / DOCUMENTATION APPENDIX
       (Intentionally verbose; also serves as a one-shot “spec + notes” inside file)

       ============================================================================

       Controls
       --------
       - Jump:
         * Space
         * Up Arrow
         * Mouse click / Touch tap

       - Restart:
         * R
         * Click/tap when on Game Over

       - Mute:
         * M
         * Mute button in HUD

       Gameplay Feel Notes
       -------------------
       Geometry Dash’s “feel” comes from:
       - Constant forward speed (world scroll)
       - Clean, predictable jump arc
       - Tight collision (but fair)
       - Instant restart loop
       - High-contrast obstacles
       - Rhythm / beat pulse (visual + audio)

       This implementation includes:
       - Fixed timestep update:
         CONFIG.fixedDt = 1/120
         so physics is stable and input timing feels consistent.

       - Jump buffering:
         CONFIG.jumpBuffer = 0.105 seconds
         If the player presses jump shortly before landing, the jump triggers
         on landing, making it feel more responsive.

       - Coyote time:
         CONFIG.coyoteTime = 0.085 seconds
         If the player walks off the ground edge (rare here), they still can
         jump shortly after leaving ground, improving feel.

       - Speed ramp:
         worldSpeed starts at CONFIG.baseSpeed and increases by
         CONFIG.speedRampPerSec every second until CONFIG.maxSpeed.

       - Procedural “pattern generator”:
         Instead of pure random, we spawn patterns S1, S2, S3, B1, SB, BS.
         This keeps runs “level-like”, with controlled difficulty.

       - Parallax background:
         Stars (far) + neon hills (mid) + grid (near) are all offset by worldDist
         using different factors.

       - Beat pulse:
         computePulse() uses BPM to create a rhythmic glow. This influences:
         - glow intensity
         - background accents
         - particle glow

       Collision Fairness
       ------------------
       - Player uses an AABB (axis-aligned) rect (classic GD-like fairness).
       - For blocks: AABB overlap.
       - For spikes: triangle intersection with a smaller “fairnessRect”
         early-reject, then rect-triangle test.

       Scoring
       -------
       - Distance-based:
         score += worldSpeed * dt * CONFIG.scorePerUnit
       - Best score stored in localStorage key:
         "neon_dash_best"

       WebAudio
       --------
       - No external files.
       - Music:
         * scheduled ahead using audio.tickMusic()
         * simple melody + chord pad + kick/snare approximations
       - SFX:
         * Jump: quick triangle sweep
         * Death: filtered noise burst
         * Tick: short sine click every 100 score points

       If you want to “tighten” or “loosen” gameplay:
       ---------------------------------------------
       - Make jumps higher:
         Increase CONFIG.jumpSpeed

       - Make gravity stronger (snappier falls):
         Increase CONFIG.gravity

       - Make timing easier:
         Increase CONFIG.jumpBuffer and CONFIG.coyoteTime a bit

       - Make harder:
         Increase CONFIG.speedRampPerSec
         Decrease CONFIG.minGap / CONFIG.maxGap
         Increase probability of S2/S3 in choosePattern()

       - Make collisions more forgiving:
         Increase "inset" inside update() for prFair (player collision shrink)

       Performance Tips
       ----------------
       - Canvas drawing is lightweight (simple shapes).
       - Fixed dt ensures stable simulation even if dt spikes (clamped by maxFrameDt).
       - Obstacles are removed when off-screen.

       ============================================================================

       (The long appendix also helps satisfy the “very long one-shot file” request.)

       ============================================================================ */
  </script>
</body>
</html>
