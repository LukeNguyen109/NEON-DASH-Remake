<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"
  />
  <title>Neon Dash || LukeNguyen109</title>

  <style>
    /* =============================================================================
       NEON DASH — Single-file, Canvas-based, Geometry-Dash-style runner
       - No external build tools
       - No external audio files (WebAudio synth music + SFX)
       - Mobile friendly
       Authored by Phu Trung (Luke) Nguyen
       25 December 2025
       ============================================================================= */

    /* Music menu */
    .musicBox{
    margin-top: 12px;
    padding-top: 12px;
    border-top: 1px solid rgba(255,255,255,0.10);
    }
    .musicLabel{
    font-family: var(--mono);
    font-size: 12px;
    color: var(--txtDim);
    letter-spacing: 0.06em;
    margin-bottom: 8px;
    text-transform: uppercase;
    }
    .musicRow{
    display: flex;
    gap: 10px;
    align-items: center;
    flex-wrap: wrap;
    }
    .select{
    appearance: none;
    border: 1px solid var(--stroke2);
    background: var(--btn);
    color: var(--txt);
    border-radius: var(--radius2);
    padding: 10px 12px;
    font-family: var(--mono);
    font-weight: 700;
    font-size: 12px;
    letter-spacing: 0.02em;
    cursor: pointer;
    min-width: 220px;
    color-scheme: dark;
    padding-right: 34px;
    }

    .select:hover{
    background: var(--btnH);
    border-color: rgba(255,255,255,0.35);
    }

    .select:focus{
      outline: none;
      border-color: rgba(125, 249, 255, 0.55);
      box-shadow: 0 0 0 3px rgba(125, 249, 255, 0.18);
    }

    /* Style the dropdown list itself (Chromium supports this reasonably well) */
    .select option{
      background: rgba(10, 10, 25, 0.98); /* matches your panel vibe */
      color: var(--txt);
    }

    .select option:disabled{
      color: var(--txtDim);
    }

    .selectWrap{
      position: relative;
      display: inline-block;
      min-width: 220px; /* same as your select */
    }

    .selectWrap::after{
      content: "▾";
      position: absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      color: var(--txtDim);
      pointer-events: none; /* keep clicks going to the select */
      font-family: var(--mono);
      font-weight: 800;
    }


    :root
    {
      --bg0: #060612;
      --bg1: #0b0b20;
      --bg2: #120a22;

      --neonA: #7df9ff;
      --neonB: #ff4dff;
      --neonC: #7cfc9a;
      --neonD: #ffd36b;

      --panel: rgba(10, 10, 25, 0.78);
      --panel2: rgba(20, 12, 35, 0.78);

      --stroke: rgba(255, 255, 255, 0.15);
      --stroke2: rgba(255, 255, 255, 0.22);

      --shadow: rgba(0, 0, 0, 0.35);

      --txt: rgba(255, 255, 255, 0.92);
      --txtDim: rgba(255, 255, 255, 0.70);
      --txtFaint: rgba(255, 255, 255, 0.55);

      --btn: rgba(255, 255, 255, 0.08);
      --btnH: rgba(255, 255, 255, 0.16);
      --btnA: rgba(255, 255, 255, 0.22);

      --radius: 14px;
      --radius2: 10px;

      --hudGap: 10px;

      --mono:
        ui-monospace,
        SFMono-Regular,
        Menlo,
        Monaco,
        Consolas,
        "Liberation Mono",
        "Courier New",
        monospace;

      --ui:
        system-ui,
        -apple-system,
        Segoe UI,
        Roboto,
        Helvetica,
        Arial,
        "Apple Color Emoji",
        "Segoe UI Emoji";
    }

    html,
    body
    {
      height: 100%;
      margin: 0;
      background: radial-gradient(
        1200px 800px at 30% 10%,
        var(--bg2),
        var(--bg1),
        var(--bg0)
      );
      overflow: hidden;
      font-family: var(--ui);
      color: var(--txt);
    }

    #app
    {
      position: relative;
      width: 100%;
      height: 100%;
      user-select: none;
      -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    canvas#game
    {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      background: transparent;
    }

    /* =============================================================================
       HUD (Score / Best / Speed + Buttons)
       ============================================================================= */

    #hud
    {
      position: absolute;
      left: 14px;
      top: 14px;
      right: 14px;
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 14px;
      pointer-events: none; /* allow clicks through except on buttons */
    }

    .hudBox
    {
      pointer-events: auto;
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      border: 1px solid var(--stroke2);
      border-radius: var(--radius);
      box-shadow:
        0 12px 32px var(--shadow),
        0 0 28px rgba(125, 249, 255, 0.10),
        0 0 28px rgba(255, 77, 255, 0.08);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    .hudLeft
    {
      padding: 12px 14px;
      min-width: 220px;
    }

    .hudRight
    {
      padding: 10px 10px;
      display: flex;
      align-items: center;
      gap: var(--hudGap);
    }

    .hudTitle
    {
      font-family: var(--mono);
      letter-spacing: 0.12em;
      font-weight: 800;
      font-size: 12px;
      color: var(--txtDim);
      margin-bottom: 8px;
      text-transform: uppercase;
    }

    .hudRow
    {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      align-items: baseline;
      line-height: 1.2;
      margin: 2px 0;
      font-family: var(--mono);
    }

    .hudRow span:first-child
    {
      color: var(--txtFaint);
      font-size: 12px;
      letter-spacing: 0.02em;
    }

    .hudRow span:last-child
    {
      color: var(--txt);
      font-size: 13px;
      font-weight: 700;
    }

    .btn
    {
      appearance: none;
      border: 1px solid var(--stroke2);
      background: var(--btn);
      color: var(--txt);
      border-radius: var(--radius2);
      padding: 10px 12px;
      font-family: var(--mono);
      font-weight: 700;
      font-size: 12px;
      letter-spacing: 0.02em;
      cursor: pointer;
      box-shadow:
        0 10px 22px rgba(0, 0, 0, 0.22),
        inset 0 0 0 1px rgba(255, 255, 255, 0.05);
      transition:
        transform 120ms ease,
        background 120ms ease,
        border-color 120ms ease;
    }

    .btn:hover
    {
      background: var(--btnH);
      border-color: rgba(255, 255, 255, 0.35);
      transform: translateY(-1px);
    }

    .btn:active
    {
      background: var(--btnA);
      transform: translateY(0px);
    }

    .btn.big
    {
      font-size: 13px;
      padding: 12px 14px;
    }

    .btn.primary
    {
      border-color: rgba(125, 249, 255, 0.55);
      box-shadow:
        0 10px 22px rgba(0, 0, 0, 0.24),
        0 0 18px rgba(125, 249, 255, 0.12),
        inset 0 0 0 1px rgba(125, 249, 255, 0.12);
    }

    .btn.danger
    {
      border-color: rgba(255, 77, 255, 0.55);
      box-shadow:
        0 10px 22px rgba(0, 0, 0, 0.24),
        0 0 18px rgba(255, 77, 255, 0.12),
        inset 0 0 0 1px rgba(255, 77, 255, 0.10);
    }

    /* =============================================================================
       Overlay (Menu / Game Over)
       ============================================================================= */

    #overlay
    {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 18px;
      background: radial-gradient(
        800px 500px at 50% 45%,
        rgba(0, 0, 0, 0.28),
        rgba(0, 0, 0, 0.65)
      );
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
    }

    #overlay.hidden
    {
      display: none;
    }

    .panel
    {
      width: min(560px, 96vw);
      border-radius: 18px;
      border: 1px solid var(--stroke2);
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      box-shadow:
        0 24px 60px rgba(0, 0, 0, 0.50),
        0 0 40px rgba(125, 249, 255, 0.10),
        0 0 40px rgba(255, 77, 255, 0.08);
      padding: 18px 18px 14px 18px;
    }

    .panelHeader
    {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 14px;
      margin-bottom: 10px;
    }

    .panelTitle
    {
      font-family: var(--mono);
      font-weight: 900;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      font-size: 18px;
      margin: 0;
      line-height: 1.0;
    }

    .panelSubtitle
    {
      font-family: var(--mono);
      font-size: 12px;
      color: var(--txtDim);
      letter-spacing: 0.06em;
      margin-top: 6px;
    }

    .panelBody
    {
      margin-top: 12px;
      padding: 14px 14px;
      border: 1px solid rgba(255, 255, 255, 0.10);
      border-radius: 14px;
      background: rgba(0, 0, 0, 0.18);
    }

    .panelBody p
    {
      margin: 0 0 10px 0;
      color: var(--txt);
      line-height: 1.45;
      font-size: 14px;
    }

    .panelBody .hintLine
    {
      margin-top: 8px;
      color: var(--txtDim);
      font-family: var(--mono);
      font-size: 12px;
      line-height: 1.35;
    }

    .panelActions{
    margin-top: 12px;
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    justify-content: flex-end;
    }

    .tagRow
    {
      margin-top: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .tag
    {
      font-family: var(--mono);
      font-size: 11px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(255, 255, 255, 0.06);
      color: var(--txtDim);
      letter-spacing: 0.02em;
    }

    /* =============================================================================
       Tiny toast (optional)
       ============================================================================= */

    #toast
    {
      position: absolute;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.44);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 999px;
      padding: 10px 14px;
      font-family: var(--mono);
      font-size: 12px;
      color: var(--txtDim);
      box-shadow: 0 14px 30px rgba(0, 0, 0, 0.30);
    }

    #toast.hidden
    {
      display: none;
    }

    /* =============================================================================
       Mobile tweaks
       ============================================================================= */

    @media (max-width: 520px)
    {
      .hudLeft
      {
        min-width: 0;
        padding: 10px 12px;
      }

      .hudRow span:first-child
      {
        font-size: 11px;
      }

      .hudRow span:last-child
      {
        font-size: 12px;
      }

      .btn
      {
        padding: 10px 10px;
      }

      .panelTitle
      {
        font-size: 16px;
      }
    }
  
    /* =============================================================================
       BEST SCORE panel (GAME OVER only)
       Pixel-ish, white→gold gradient + flame wings outline
       ============================================================================= */
    .bestScorePanel{
      position: relative;
      margin-top: 14px;
      padding: 12px 12px;
      border: 2px solid rgba(255, 220, 140, 0.65);
      background:
        linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,205,100,0.12)),
        radial-gradient(120% 120% at 50% 0%, rgba(255,220,140,0.16), rgba(0,0,0,0) 60%);
      box-shadow:
        0 0 0 2px rgba(0,0,0,0.35) inset,
        0 10px 30px rgba(0,0,0,0.45);
      border-radius: 10px;
      transform: translateZ(0);
      overflow: visible;
    }

    .bestScorePanel.hidden{ display:none; }

    /* Corner badge PNG (top-right, 45° tilt) */
    .bestScoreBadge{
      position: absolute;
      top: var(--badgeTop);
      left: var(--badgeLeft);
      width: 86px;
      height: auto;
      transform:
        translate(var(--badgeTx), var(--badgeTy))
        rotate(var(--badgeRot))
        scale(var(--badgeScale));
      transform-origin: 50% 50%;
      pointer-events: none;
      image-rendering: pixelated;
      filter: drop-shadow(0 10px 18px rgba(0,0,0,0.45));
      opacity: 0.98;
      
      --badgeTop: -30px;     /* down +, up - */
      --badgeLeft: 225px;    /* right +, left - */
      --badgeTx: 0px;
      --badgeTy: 0px;
      --badgeRot: 0deg;
      --badgeScale: 1;

    }
    @media (max-width: 520px){
      .bestScoreBadge{
        width: 70px;
        top: -14px;
        right: -14px;
      }
    }


    .bestScoreInner{
      position: relative;
      border: 2px solid rgba(255, 255, 255, 0.18);
      background:
        repeating-linear-gradient(
          90deg,
          rgba(255,255,255,0.02) 0px,
          rgba(255,255,255,0.02) 6px,
          rgba(255,255,255,0.00) 6px,
          rgba(255,255,255,0.00) 12px
        );
      border-radius: 8px;
      padding: 10px 10px;
    }

    .bestScoreTitle{
      font-weight: 900;
      letter-spacing: 0.10em;
      text-transform: uppercase;
      font-size: 0.92rem;
      background: linear-gradient(90deg, rgba(255,255,255,0.98), rgba(255,214,125,0.98));
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      text-shadow:
        0 0 0 rgba(0,0,0,0.0),
        0 2px 0 rgba(0,0,0,0.35);
    }

    .bestScoreValue{
      margin-top: 2px;
      font-weight: 1000;
      font-size: 2.05rem;
      line-height: 1.0;
      background: linear-gradient(90deg, rgba(255,255,255,0.98), rgba(255,196,80,0.98));
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      text-shadow:
        0 2px 0 rgba(0,0,0,0.45),
        0 0 18px rgba(255, 200, 90, 0.20);
    }

    /* Flame wing outline (pixel-y steps via repeating gradients) */
    .bestScoreWings{
      position:absolute;
      left:50%;
      top:50%;
      width: calc(100% + 62px);
      height: calc(100% + 22px);
      transform: translate(-50%, -50%);
      pointer-events: none;
      filter: drop-shadow(0 10px 18px rgba(0,0,0,0.35));
    }
    .bestScoreWings::before,
    .bestScoreWings::after{
      content:"";
      position:absolute;
      top: 50%;
      width: 46px;
      height: 46px;
      transform: translateY(-50%);
      background:
        linear-gradient(180deg, rgba(255,255,255,0.55), rgba(255,205,100,0.55)),
        repeating-linear-gradient(
          90deg,
          rgba(255,255,255,0.10) 0px,
          rgba(255,255,255,0.10) 4px,
          rgba(255,255,255,0.00) 4px,
          rgba(255,255,255,0.00) 8px
        );
      border: 2px solid rgba(255, 220, 140, 0.65);
      box-shadow: 0 0 0 2px rgba(0,0,0,0.35) inset;
      /* jagged, flame-wing-ish silhouette */
      clip-path: polygon(0% 55%, 10% 35%, 25% 45%, 35% 25%, 52% 42%, 64% 18%, 82% 38%, 100% 50%, 82% 62%, 64% 82%, 52% 58%, 35% 75%, 25% 55%, 10% 68%);
    }
    .bestScoreWings::before{ left: 0; }
    .bestScoreWings::after{ right: 0; transform: translateY(-50%) scaleX(-1); }

    /* Show animation (rare + prestigious) */
    .bestScorePanel.show{
      animation: bestPop 620ms cubic-bezier(.12,1.45,.22,1) both, bestShake 420ms ease-out 620ms 1;
    }
    .bestScorePanel.show .bestScoreWings::before,
    .bestScorePanel.show .bestScoreWings::after{
      animation: wingIgnite 850ms ease-out both;
    }
    .bestScorePanel.show .bestScoreValue{
      animation: scoreFlicker 900ms ease-out both;
    }

    @keyframes bestPop{
      0%   { transform: scale(0.70); opacity: 0; }
      60%  { transform: scale(1.06); opacity: 1; }
      100% { transform: scale(1.00); opacity: 1; }
    }
    @keyframes bestShake{
      0%   { transform: scale(1.00) translateX(0px); }
      20%  { transform: scale(1.00) translateX(-2px); }
      40%  { transform: scale(1.00) translateX(2px); }
      60%  { transform: scale(1.00) translateX(-1px); }
      100% { transform: scale(1.00) translateX(0px); }
    }
    @keyframes wingIgnite{
      0%   { opacity: 0; transform: translateY(-50%) scale(0.85); filter: drop-shadow(0 0 0 rgba(0,0,0,0)); }
      40%  { opacity: 1; transform: translateY(-50%) scale(1.03); filter: drop-shadow(0 0 18px rgba(255, 200, 90, 0.20)); }
      100% { opacity: 1; transform: translateY(-50%) scale(1.00); filter: drop-shadow(0 0 12px rgba(255, 200, 90, 0.12)); }
    }
    @keyframes scoreFlicker{
      0%   { text-shadow: 0 2px 0 rgba(0,0,0,0.45), 0 0 0 rgba(255,200,90,0.0); }
      25%  { text-shadow: 0 2px 0 rgba(0,0,0,0.45), 0 0 26px rgba(255,200,90,0.30); }
      55%  { text-shadow: 0 2px 0 rgba(0,0,0,0.45), 0 0 14px rgba(255,200,90,0.18); }
      100% { text-shadow: 0 2px 0 rgba(0,0,0,0.45), 0 0 18px rgba(255,200,90,0.20); }
    }
</style>
</head>

<body>
  <div id="app">
    <canvas id="game"></canvas>

    <div id="hud">
      <div class="hudBox hudLeft">
        <div class="hudTitle">NEON DASH</div>

        <div class="hudRow">
          <span>Score</span>
          <span id="uiScore">0</span>
        </div>

        <div class="hudRow">
          <span>Last</span>
          <span id="uiLast">0</span>
        </div>

        <div class="hudRow">
          <span>Best</span>
          <span id="uiBest">0</span>
        </div>

        <div class="hudRow">
          <span>Speed</span>
          <span id="uiSpeed">1.00x</span>
        </div>

        <div class="hudRow">
          <span>State</span>
          <span id="uiState">MENU</span>
        </div>
      </div>

      <div class="hudBox hudRight">
        <button id="btnMute" class="btn">Mute (M)</button>
        <button id="btnRestartTop" class="btn danger">Restart (R)</button>
      </div>
    </div>

    <div id="overlay">
      <div class="panel">
        <div class="panelHeader">
          <div>
            <h1 class="panelTitle" id="panelTitle">NEON DASH</h1>
            <div class="panelSubtitle" id="panelSubtitle">
              Geometry-Dash-style rhythm runner
            </div>
          </div>
          <div class="tagRow">
            <span class="tag" id="tagA">60fps</span>
            <span class="tag" id="tagB">WebAudio</span>
            <span class="tag" id="tagC">Procedural</span>
          </div>
        </div>

        <div class="panelBody">
        <p id="panelText">
            Press <b>Start</b> to start.<br/>
            Time your jumps. One hit = boom.
        </p>

        <!-- Best score celebration (GAME OVER only, shown only on new best) -->
        <div id="bestScorePanel" class="bestScorePanel hidden" aria-hidden="true">
          <img id="bestScoreBadge" class="bestScoreBadge" src="./static/dk.png" alt="" aria-hidden="true" />
          <div class="bestScoreWings" aria-hidden="true"></div>
          <div class="bestScoreInner">
            <div class="bestScoreTitle">BEST SCORE</div>
            <div class="bestScoreValue" id="bestScoreValue">0</div>
          </div>
        </div>


        <!-- Music menu (MENU + GAMEOVER) -->
        <div id="musicPanel" class="musicBox">
            <div class="musicLabel">Music</div>

            <div class="musicRow">
            <select id="musicSelect" class="select"></select>
            <button id="btnPreview" class="btn">Preview</button>
            </div>
        </div>

        <!-- Speed ramp menu (MENU + GAMEOVER) -->
        <div id="speedPanel" class="musicBox">
          <div class="musicLabel">Speed</div>

        <div class="musicRow">
          <input
            id="speedSlider"
            type="range"
            min="0"
            max="20"
            step="0.5"
            value="10"
            class="select"
            style="padding: 0 10px;"
          />

          <span
            id="speedValue"
            class="tag"
            style="min-width:48px; text-align:center;"
          >
            5.5
          </span>

          <button id="btnSpeedReset" class="btn">Reset</button>
        </div>

          <div class="hintLine" style="margin-top:8px;">
            Higher = difficulty increases faster.
          </div>
        </div>

        <div class="hintLine">
            Jump: Space / Up / Click / Tap<br/>
            Restart: R (or tap after death)<br/>
            Mute: M
        </div>
        </div>

        <div class="panelActions">
        <button id="btnStart" class="btn big primary">Start</button>
        <button id="btnRestart" class="btn big danger" style="display:none;">Restart</button>
        </div>
      </div>
    </div>

    <div id="toast" class="hidden">Audio unlocked ✓</div>
  </div>

  <script>
    "use strict";

    /* =============================================================================
       NEON DASH — JavaScript
       =============================================================================
       Key goals:
       - Constant forward motion (world scroll)
       - Jump timing feels “snappy” with:
         * coyote time (grace after leaving ground)
         * jump buffering (press slightly early, jumps on landing)
       - Procedural obstacles (fair + difficulty ramps)
       - Collision (AABB for blocks, triangle intersection for spikes)
       - Game states (Menu → Playing → Game Over) + instant restart
       - Polished UI + neon visuals + parallax background
       - WebAudio music + jump/death SFX with autoplay restrictions handled
       ============================================================================= */

    /* =============================================================================
       DOM
       ============================================================================= */
    const musicPanel =
        document.getElementById("musicPanel");

    const musicSelect =
        document.getElementById("musicSelect");

    const btnPreview =
        document.getElementById("btnPreview");

    const speedSlider =
      document.getElementById("speedSlider");

    const btnSpeedReset =
      document.getElementById("btnSpeedReset");

    const speedValue =
      document.getElementById("speedValue");

    const canvas =
      document.getElementById("game");

    const ctx =
      canvas.getContext("2d", { alpha: true });

    const uiScore =
      document.getElementById("uiScore");

    const uiLast =
      document.getElementById("uiLast");

    const uiBest =
      document.getElementById("uiBest");

    const uiSpeed =
      document.getElementById("uiSpeed");

    const uiState =
      document.getElementById("uiState");

    const overlay =
      document.getElementById("overlay");

    const panelTitle =
      document.getElementById("panelTitle");

    const panelSubtitle =
      document.getElementById("panelSubtitle");

    const panelText =
      document.getElementById("panelText");

    const bestScorePanel =
      document.getElementById("bestScorePanel");

    const bestScoreValueEl =
      document.getElementById("bestScoreValue");

    const bestScoreBadgeEl =
      document.getElementById("bestScoreBadge");

    const btnStart =
      document.getElementById("btnStart");

    const btnRestart =
      document.getElementById("btnRestart");

    const btnMute =
      document.getElementById("btnMute");

    const btnRestartTop =
      document.getElementById("btnRestartTop");

    const toast =
      document.getElementById("toast");

    /* =============================================================================
       Utility — math helpers
       ============================================================================= */

    const clamp =
      (v, a, b) =>
        Math.max(a, Math.min(b, v));

    const lerp =
      (a, b, t) =>
        a + (b - a) * t;

    const rand =
      (a, b) =>
        a + Math.random() * (b - a);

    const randInt =
      (a, b) =>
        Math.floor(rand(a, b + 1));

    const sign =
      (v) =>
        v < 0 ? -1 : 1;

    const TAU =
      Math.PI * 2;

    /* =============================================================================
       Config (tuned for “Geometry Dash” feel)
       ============================================================================= */

    const CONFIG =
    {
      // Rendering
      dprMax:
        2.0,

      // World layout
      groundFrac:
        0.80,           // ground line Y = height * groundFrac

      // Player
      playerSize:
        42,

      playerXFrac:
        0.25,           // player's fixed screen X = width * playerXFrac

      gravity:
        // 3400,           // px/s^2
        4500,

      jumpSpeed:
        1180,           // px/s (impulse)

      maxFallSpeed:
        2100,           // clamp

      // “Geometry Dash” niceties
      coyoteTime:
        0.085,          // seconds

      jumpBuffer:
        0.105,          // seconds

      // Rotation visuals
      rotPerSecond:
        9.0,            // base rotation speed

      rotSnapStrength:
        18.0,           // landing rotation smoothing

      // Difficulty curve
      baseSpeed:
        600,            // px/s

      maxSpeed:
        1500,            // px/s

      speedRampPerSec:
        13,           // px/s per second

      // Spawn control
      spawnAhead:
        1200,           // how far ahead we ensure spawns exist (world units)

      minGap:
        625,            // minimum pattern gap

      maxGap:
        1050,            // maximum pattern gap

      // Obstacle sizes
      spikeWidth:
        44,

      spikeHeight:
        46,

      blockMin:
        44,

      blockMax:
        68,

      // Particles
      trailRate: //number of trail particles per second
        100,             // per second

      deathParticles:
        95,

      // Screen shake
      shakeTime:
        0.22,

      shakeMag:
        14,

      // Scoring
      scorePerUnit:
        0.010,          // score += speed * dt * scorePerUnit
                         // (distance based)

      // Beat pulse (visual + music)
      bpm:
        144,

      // Fixed timestep
      fixedDt:
        1 / 120,

      maxFrameDt:
        1 / 20,
    };

    /* =============================================================================
       Global runtime values (set on resize)
       ============================================================================= */

    let W = 0;
    let H = 0;

    let DPR = 1;

    let groundY = 0;
    let playerX = 0;

    function resizeCanvas()
    {
      DPR =
        Math.min(
          CONFIG.dprMax,
          window.devicePixelRatio || 1
        );

      W =
        Math.floor(window.innerWidth);

      H =
        Math.floor(window.innerHeight);

      canvas.width =
        Math.floor(W * DPR);

      canvas.height =
        Math.floor(H * DPR);

      canvas.style.width =
        W + "px";

      canvas.style.height =
        H + "px";

      ctx.setTransform(
        DPR, 0,
        0, DPR,
        0, 0
      );

      groundY =
        Math.floor(H * CONFIG.groundFrac);

      playerX =
        Math.floor(W * CONFIG.playerXFrac);
    }

    window.addEventListener("resize", resizeCanvas);

    resizeCanvas();

    /* =============================================================================
       Audio Manager (WebAudio synth music + SFX)
       =============================================================================
       - Autoplay restrictions: only start after user interaction.
       - Music loops via scheduled notes.
       - Mute toggles master gain.
       ============================================================================= */

    class AudioManager
    {
      constructor()
      {
        this.ctx = null;
        this.musicEl = null;              // HTMLAudioElement for MP3 music
        this.trackId = "synth";           // selected track id
        this.trackType = "synth";         // "synth" | "file" | "off"
        this.trackUrl = "";               // for file tracks
        this.previewing = false;
        this.fileMusicVolume = 0.55;

        // One-shot MP3 SFX pool (checkpoint celebrations)
        // Kept separate from WebAudio graph so it can use your ./static/*.mp3 files.
        this._oneshotPool = new Map();

        // New-best-score MP3 (blocks jump-to-restart while playing)
        this._bestScoreSfx = null;
        this._bestScoreSfxPlaying = false;

        this.master =
          null;

        this.musicGain =
          null;

        this.sfxGain =
          null;

        this.muted =
          false;

        this.unlocked =
          false;

        this.musicOn =
          false;

        this.bpm =
          CONFIG.bpm;

        this.beatDur =
          60 / this.bpm;

        this.musicTimer =
          0;

        this.musicStep =
          0;

        this.nextNoteTime =
          0;

        this._notes =
          [
            220.00, // A3
            246.94, // B3
            261.63, // C4
            293.66, // D4
            329.63, // E4
            392.00, // G4
          ];

        this._pattern =
          [
            0, 2, 4, 2,
            1, 3, 5, 3,
            0, 2, 4, 2,
            1, 3, 5, 4,
          ];

        this._chord =
          [ 0, 4, 5 ];

        this._startedAt =
          0;
      }
      _ensureMusicEl()
        {
        if (this.musicEl) return;

        this.musicEl = new Audio();
        this.musicEl.loop = true;
        this.musicEl.preload = "auto";
        this.musicEl.volume = this.fileMusicVolume;
        this.musicEl.muted = this.muted;
        }

        setMusicTrack(track)
        {
        // track = { id, type, url? }
        if (!track) return;

        // stop any current music before switching
        this.stopMusic();

        this.trackId = track.id;
        this.trackType = track.type;

        if (track.type === "file")
        {
            this.trackUrl = track.url || "";
            this._ensureMusicEl();
            this.musicEl.src = this.trackUrl;
        }
        else
        {
            this.trackUrl = "";
            if (this.musicEl) this.musicEl.removeAttribute("src");
        }
        }

        async _playFileMusic()
        {
        this._ensureMusicEl();
        if (!this.trackUrl) return;

        this.musicEl.muted = this.muted;
        this.musicEl.volume = this.fileMusicVolume;

        try
        {
            await this.musicEl.play();
        }
        catch (e)
        {
            // autoplay restrictions or load fail — will work after another gesture
        }
        }

        _stopFileMusic()
        {
        if (!this.musicEl) return;
        this.musicEl.pause();
        this.musicEl.currentTime = 0;
        }

        isPreviewing()
        {
        return this.previewing;
        }

        async previewToggle()
        {
        // Preview only matters for file tracks; for synth we just start/stop synth music.
        if (this.trackType === "off")
        {
            this.previewing = false;
            this.stopMusic();
            return;
        }

        if (!this.previewing)
        {
            this.previewing = true;
            this.startMusic(); // reuse start logic
        }
        else
        {
            this.previewing = false;
            this.stopMusic();
        }
        }


      ensure()
      {
        if (this.ctx) return;

        const AC =
          window.AudioContext ||
          window.webkitAudioContext;

        this.ctx =
          new AC();

        this.master =
          this.ctx.createGain();

        this.musicGain =
          this.ctx.createGain();

        this.sfxGain =
          this.ctx.createGain();

        this.master.gain.value =
          0.85;

        this.musicGain.gain.value =
          0.45;

        this.sfxGain.gain.value =
          0.65;

        this.musicGain.connect(this.master);
        this.sfxGain.connect(this.master);

        this.master.connect(this.ctx.destination);

        this._startedAt =
          this.ctx.currentTime;

        this.nextNoteTime =
          this.ctx.currentTime + 0.05;
      }

      async unlock()
      {
        this.ensure();

        if (this.unlocked) return;

        try
        {
          await this.ctx.resume();
          this.unlocked = true;
          showToast("Audio unlocked ✓");
        }
        catch (e)
        {
          // If resume fails, we'll try again on next user input.
        }
      }

    setMuted(flag)
    {
    this.muted = !!flag;

    if (this.master)
    {
        this.master.gain.value =
        this.muted ? 0.0 : 0.85;
    }

    if (this.musicEl)
    {
        this.musicEl.muted = this.muted;
    }

    if (this._bestScoreSfx)
    {
        this._bestScoreSfx.muted = this.muted;
    }

    btnMute.textContent =
        this.muted ? "Unmute (M)" : "Mute (M)";
    }


      toggleMute()
      {
        this.setMuted(!this.muted);
      }

    startMusic()
    {
    this.ensure();

    if (this.trackType === "off")
    {
        this.musicOn = false;
        this._stopFileMusic();
        return;
    }

    if (this.trackType === "file")
    {
        this.musicOn = false;     // synth scheduler off
        this._playFileMusic();
        return;
    }

    // default: synth
    this._stopFileMusic();

    this.musicOn = true;
    this.musicStep = 0;
    this.nextNoteTime = this.ctx.currentTime + 0.05;
    }


    stopMusic()
    {
    this.musicOn = false;   // stops synth scheduling
    this._stopFileMusic();  // stops mp3 if any
    this.previewing = false;
    }

      // Called frequently (each update) to schedule notes slightly ahead.
      tickMusic()
      {
        if (!this.ctx) return;
        if (!this.musicOn) return;       // synth only
        if (!this.unlocked) return;
        if (this.muted) return;

        const scheduleAhead =
          0.25;

        while (this.nextNoteTime < this.ctx.currentTime + scheduleAhead)
        {
          const stepIndex =
            this.musicStep % this._pattern.length;

          const noteIndex =
            this._pattern[stepIndex];

          const baseFreq =
            this._notes[noteIndex];

          const isKick =
            (this.musicStep % 4) === 0;

          const isSnare =
            (this.musicStep % 4) === 2;

          // melody blip
          this._playSynthNote(
            baseFreq,
            this.nextNoteTime,
            0.08,
            isKick ? 0.22 : 0.14
          );

          // chord pad every 8 steps
          if ((this.musicStep % 8) === 0)
          {
            const c0 =
              this._notes[this._chord[0]];

            const c1 =
              this._notes[this._chord[1]];

            const c2 =
              this._notes[this._chord[2]];

            this._playPadChord(
              [c0, c1, c2],
              this.nextNoteTime,
              0.28,
              0.12
            );

            // rotate chord occasionally
            if ((this.musicStep % 16) === 0)
            {
              this._chord.unshift(this._chord.pop());
            }
          }

          // soft kick / snare using noise + low osc
          if (isKick)
          {
            this._playKick(
              this.nextNoteTime,
              0.09,
              0.45
            );
          }
          else if (isSnare)
          {
            this._playSnare(
              this.nextNoteTime,
              0.08,
              0.25
            );
          }

          // advance
          this.musicStep += 1;
          this.nextNoteTime += this.beatDur / 2; // eighth notes
        }
      }

      _playSynthNote(freq, time, dur, amp)
      {
        const osc =
          this.ctx.createOscillator();

        const g =
          this.ctx.createGain();

        osc.type =
          "square";

        osc.frequency.setValueAtTime(freq, time);

        // tiny detune for thickness
        osc.detune.setValueAtTime(rand(-6, 6), time);

        g.gain.setValueAtTime(0.0, time);
        g.gain.linearRampToValueAtTime(amp, time + 0.01);
        g.gain.exponentialRampToValueAtTime(0.001, time + dur);

        osc.connect(g);
        g.connect(this.musicGain);

        osc.start(time);
        osc.stop(time + dur + 0.03);
      }

      _playPadChord(freqs, time, dur, amp)
      {
        for (let i = 0; i < freqs.length; i++)
        {
          const osc =
            this.ctx.createOscillator();

          const g =
            this.ctx.createGain();

          osc.type =
            "sine";

          osc.frequency.setValueAtTime(freqs[i], time);
          osc.detune.setValueAtTime(rand(-10, 10), time);

          g.gain.setValueAtTime(0.0, time);
          g.gain.linearRampToValueAtTime(amp, time + 0.02);
          g.gain.exponentialRampToValueAtTime(0.001, time + dur);

          osc.connect(g);
          g.connect(this.musicGain);

          osc.start(time);
          osc.stop(time + dur + 0.05);
        }
      }

      _playKick(time, dur, amp)
      {
        // low sine pitch drop + short envelope
        const osc =
          this.ctx.createOscillator();

        const g =
          this.ctx.createGain();

        osc.type =
          "sine";

        osc.frequency.setValueAtTime(120, time);
        osc.frequency.exponentialRampToValueAtTime(45, time + dur);

        g.gain.setValueAtTime(0.0, time);
        g.gain.linearRampToValueAtTime(amp, time + 0.006);
        g.gain.exponentialRampToValueAtTime(0.001, time + dur);

        osc.connect(g);
        g.connect(this.musicGain);

        osc.start(time);
        osc.stop(time + dur + 0.02);
      }

      _playSnare(time, dur, amp)
      {
        // noise burst
        const noise =
          this._noiseBuffer();

        const src =
          this.ctx.createBufferSource();

        src.buffer =
          noise;

        const g =
          this.ctx.createGain();

        const bp =
          this.ctx.createBiquadFilter();

        bp.type =
          "bandpass";

        bp.frequency.setValueAtTime(2200, time);

        g.gain.setValueAtTime(0.0, time);
        g.gain.linearRampToValueAtTime(amp, time + 0.005);
        g.gain.exponentialRampToValueAtTime(0.001, time + dur);

        src.connect(bp);
        bp.connect(g);
        g.connect(this.musicGain);

        src.start(time);
        src.stop(time + dur + 0.02);
      }

      _noiseBuffer()
      {
        const len =
          Math.floor(this.ctx.sampleRate * 0.12);

        const buf =
          this.ctx.createBuffer(1, len, this.ctx.sampleRate);

        const data =
          buf.getChannelData(0);

        for (let i = 0; i < len; i++)
        {
          data[i] =
            (Math.random() * 2 - 1) * 0.6;
        }

        return buf;
      }

      // SFX
      sfxJump()
      {
        if (!this.ctx) return;
        if (!this.unlocked) return;
        if (this.muted) return;

        const time =
          this.ctx.currentTime;

        const osc =
          this.ctx.createOscillator();

        const g =
          this.ctx.createGain();

        osc.type =
          "triangle";

        osc.frequency.setValueAtTime(720, time);
        osc.frequency.exponentialRampToValueAtTime(980, time + 0.07);

        g.gain.setValueAtTime(0.0, time);
        g.gain.linearRampToValueAtTime(0.35, time + 0.006);
        g.gain.exponentialRampToValueAtTime(0.001, time + 0.085);

        osc.connect(g);
        g.connect(this.sfxGain);

        osc.start(time);
        osc.stop(time + 0.10);
      }

      sfxDeath()
      {
        if (!this.ctx) return;
        if (!this.unlocked) return;
        if (this.muted) return;

        const time =
          this.ctx.currentTime;

        // noise + downward pitch
        const noise =
          this._noiseBuffer();

        const src =
          this.ctx.createBufferSource();

        src.buffer =
          noise;

        const g =
          this.ctx.createGain();

        const lp =
          this.ctx.createBiquadFilter();

        lp.type =
          "lowpass";

        lp.frequency.setValueAtTime(1800, time);
        lp.frequency.exponentialRampToValueAtTime(220, time + 0.18);

        g.gain.setValueAtTime(0.0, time);
        g.gain.linearRampToValueAtTime(0.65, time + 0.006);
        g.gain.exponentialRampToValueAtTime(0.001, time + 0.22);

        src.connect(lp);
        lp.connect(g);
        g.connect(this.sfxGain);

        src.start(time);
        src.stop(time + 0.25);
      }

      sfxTick()
      {
        if (!this.ctx) return;
        if (!this.unlocked) return;
        if (this.muted) return;

        const time =
          this.ctx.currentTime;

        const osc =
          this.ctx.createOscillator();

        const g =
          this.ctx.createGain();

        osc.type =
          "sine";

        osc.frequency.setValueAtTime(1200, time);

        g.gain.setValueAtTime(0.0, time);
        g.gain.linearRampToValueAtTime(0.18, time + 0.002);
        g.gain.exponentialRampToValueAtTime(0.001, time + 0.05);

        osc.connect(g);
        g.connect(this.sfxGain);

        osc.start(time);
        osc.stop(time + 0.06);
      }
    
      playOneShotMp3(url, vol = 0.95)
      {
        if (!url) return;
        if (this.muted) return;

        let pool =
          this._oneshotPool.get(url);

        if (!pool)
        {
          pool = [];
          this._oneshotPool.set(url, pool);
        }

        // try to reuse an idle element
        let el =
          null;

        for (let i = 0; i < pool.length; i++)
        {
          const a = pool[i];
          if (a.paused || a.ended)
          {
            el = a;
            break;
          }
        }

        if (!el)
        {
          el = new Audio(url);
          el.preload = "auto";
          pool.push(el);
        }

        el.muted =
          this.muted;

        el.volume =
          clamp(vol, 0, 1);

        try
        {
          el.currentTime = 0;
        }
        catch (e)
        {
          // ignore (can happen if not ready)
        }

        el.play().catch(() =>
        {
          // If the browser blocks it (no gesture yet), it'll work after unlock.
        });
      }



      // New best score MP3 (HTMLAudioElement) — lets gameplay logic know when it is still playing.
      playBestScoreMp3(url, vol = 0.95)
      {
        if (!url) return;
        if (this.muted) return;

        // stop any previous best-score jingle
        this.stopBestScoreMp3();

        const el = new Audio(url);
        el.preload = "auto";
        el.loop = false;
        el.muted = this.muted;
        el.volume = clamp(vol, 0, 1);

        this._bestScoreSfx = el;
        this._bestScoreSfxPlaying = true;

        const clear = () =>
        {
          if (this._bestScoreSfx === el)
          {
            this._bestScoreSfx = null;
            this._bestScoreSfxPlaying = false;
          }
        };

        el.addEventListener("ended", clear, { once: true });

        el.play().catch(() =>
        {
          // Autoplay block or load fail: don't lock input.
          clear();
        });
      }

      stopBestScoreMp3()
      {
        const el = this._bestScoreSfx;
        this._bestScoreSfx = null;
        this._bestScoreSfxPlaying = false;

        if (!el) return;

        try { el.pause(); } catch (e) {}
        try { el.currentTime = 0; } catch (e) {}
      }

      isBestScoreMp3Playing()
      {
        return !!this._bestScoreSfxPlaying;
      }

      sfxCheckpoint(cp)
      {
        // Dedicated MP3 per milestone (matches your prompt).
        const url =
          (cp === 100) ? CHECKPOINT_SFX_URLS[100] :
          (cp === 300) ? CHECKPOINT_SFX_URLS[300] :
          (cp === 500) ? CHECKPOINT_SFX_URLS[500] :
          (cp === 750) ? CHECKPOINT_SFX_URLS[750] :
          CHECKPOINT_SFX_URLS[1000]; // 1000 and every +250 after 1000

        this.playOneShotMp3(url, 0.95);
      }

}

    const audio =
      new AudioManager();

    /* =============================================================================
       Toast helper
       ============================================================================= */

    let toastTimer = 0;

    function showToast(msg)
    {
      toast.textContent =
        msg;

      toast.classList.remove("hidden");

      toastTimer =
        1.1;
    }
    // ===== Music tracks =====
    // Use "./static/..." for GitHub Pages style hosting,
    // or "/static/..." if your server mounts static at root.
    const MUSIC_TRACKS =
    [
        { id: "synth", name: "Built-in Synth (default)", type: "synth" },
        
        // Options for custom .mp3 files:
        { id: "1", name: "Mưa Đợi Chờ Remix - 10.5", type: "file", url: "./static/mua_doi_cho_remix.mp3" },
        { id: "2", name: "Hẹn Hò Nhưng Không Yêu Remix - 15", type: "file", url: "./static/hen_ho_nhung_k_iu.mp3" },
        { id: "3", name: "Anh Vui Drill - 16.5", type: "file", url: "./static/anh_vui.mp3" },
        { id: "4", name: "Đổi Tình Đổi Áo Remix - 7.5", type: "file", url: "./static/doi_tinh_doi_ao.mp3" },
        { id: "5", name: "Trả Cho Anh Remix Huy PT - 9.5", type: "file", url: "./static/tra_cho_anh_huypt.mp3" },
        { id: "6", name: "Trả Cho Anh Remix NESS - 11", type: "file", url: "./static/tra_cho_anh_ness.mp3" },
        { id: "7", name: "Đổi Tình Đổi Áo Remix có lời - 13", type: "file", url: "./static/doi_tinh_doi_ao_remix2.MP3" },
        // { id: "t2", name: "My Track 2", type: "file", url: "./static/track2.mp3" },

        { id: "off",   name: "Off",                     type: "off"   },
    ];

    function getTrackById(id)
    {
    return MUSIC_TRACKS.find(t => t.id === id) || MUSIC_TRACKS[0];
    }

    function initMusicMenu()
    {
    // populate <select>
    musicSelect.innerHTML = "";
    for (const t of MUSIC_TRACKS)
    {
        const opt = document.createElement("option");
        opt.value = t.id;
        opt.textContent = t.name;
        musicSelect.appendChild(opt);
    }

    // restore selection (robust even if you remove "synth")
    const saved = localStorage.getItem("neon_dash_track");
    const fallback = MUSIC_TRACKS[0]?.id || "off";

    const safeId =
      (saved && MUSIC_TRACKS.some(t => t.id === saved))
        ? saved
        : fallback;

    musicSelect.value = safeId;

    // apply to audio system
    audio.setMusicTrack(getTrackById(safeId));


    // apply to audio system
    audio.setMusicTrack(getTrackById(safeId));

    // on change
    musicSelect.addEventListener("change", () =>
    {
        const id = musicSelect.value;
        localStorage.setItem("neon_dash_track", id);
        audio.setMusicTrack(getTrackById(id));
        btnPreview.textContent = "Preview";
    });

    // preview button
    btnPreview.addEventListener("click", async () =>
    {
        await audio.unlock(); // required on mobile
        await audio.previewToggle();
        btnPreview.textContent = audio.isPreviewing() ? "Stop" : "Preview";
    });
    }

    initMusicMenu();

    function initSpeedMenu()
    {
      const key = "neon_dash_speedRamp";

      const saved =
        parseFloat(localStorage.getItem(key));

      if (!isNaN(saved))
      {
        CONFIG.speedRampPerSec = saved;
      }

      // sync UI
      speedSlider.value =
        CONFIG.speedRampPerSec;

      speedValue.textContent =
        CONFIG.speedRampPerSec.toFixed(1);

      // live update while dragging
      speedSlider.addEventListener("input", () =>
      {
        const v =
          parseFloat(speedSlider.value);

        CONFIG.speedRampPerSec = v;
        speedValue.textContent = v.toFixed(1);

        localStorage.setItem(key, String(v));
      });

      // reset button
      btnSpeedReset.addEventListener("click", () =>
      {
        const def = 5.5;

        CONFIG.speedRampPerSec = def;
        speedSlider.value = def;
        speedValue.textContent = def.toFixed(1);

        localStorage.setItem(key, String(def));
      });
    }


    initSpeedMenu();

    /* =============================================================================
       Input handling
       ============================================================================= */

    const input =
    {
      jumpPressed:
        false,

      jumpHeld:
        false,

      restartPressed:
        false,

      mutePressed:
        false,

      anyPressed:
        false,

      pointerDown:
        false,
    };

    function consumeEdgeFlags()
    {
      input.jumpPressed = false;
      input.restartPressed = false;
      input.mutePressed = false;
      input.anyPressed = false;
    }

    function onKeyDown(e)
    {
      const k =
        e.key.toLowerCase();

      // prevent page scrolling on Space/Arrow
      if (k === " " || k === "arrowup" || k === "arrowdown")
      {
        e.preventDefault();
      }

      input.anyPressed = true;

      if (k === " " || k === "arrowup")
      {
        input.jumpPressed = true;
        input.jumpHeld = true;
      }

      if (k === "r")
      {
        input.restartPressed = true;
      }

      if (k === "m")
      {
        input.mutePressed = true;
      }
    }

    function onKeyUp(e)
    {
      const k =
        e.key.toLowerCase();

      if (k === " " || k === "arrowup")
      {
        input.jumpHeld = false;
      }
    }

    window.addEventListener("keydown", onKeyDown, { passive: false });
    window.addEventListener("keyup", onKeyUp, { passive: true });

    // Pointer / touch
    function onPointerDown(e)
    {
    // If MENU / GAMEOVER overlay is up, don't let canvas clicks start/jump.
    if (!overlay.classList.contains("hidden")) return;

    // Best effort unlock (helps if you start by clicking)
    audio.unlock();

    input.anyPressed = true;
    input.jumpPressed = true;
    input.pointerDown = true;
    }


    function onPointerUp(e)
    {
      input.pointerDown = false;
    }

    canvas.addEventListener("pointerdown", onPointerDown, { passive: true });
    window.addEventListener("pointerup", onPointerUp, { passive: true });

    // UI buttons
    btnStart.addEventListener("click", async () =>
    {
      await audio.unlock();
      startFromMenu();
    });

    btnRestart.addEventListener("click", async () =>
    {
      await audio.unlock();
      restartRun();
    });

    btnMute.addEventListener("click", async () =>
    {
      await audio.unlock();
      audio.toggleMute();
    });

    btnRestartTop.addEventListener("click", async () =>
    {
      await audio.unlock();
      restartRun();
    });

    /* =============================================================================
       Geometry / collision helpers
       ============================================================================= */

    function rectsOverlap(a, b)
    {
      return (
        a.x < b.x + b.w &&
        a.x + a.w > b.x &&
        a.y < b.y + b.h &&
        a.y + a.h > b.y
      );
    }

    function pointInTriangle(px, py, ax, ay, bx, by, cx, cy)
    {
      // Barycentric technique
      const v0x = cx - ax;
      const v0y = cy - ay;

      const v1x = bx - ax;
      const v1y = by - ay;

      const v2x = px - ax;
      const v2y = py - ay;

      const dot00 = v0x * v0x + v0y * v0y;
      const dot01 = v0x * v1x + v0y * v1y;
      const dot02 = v0x * v2x + v0y * v2y;
      const dot11 = v1x * v1x + v1y * v1y;
      const dot12 = v1x * v2x + v1y * v2y;

      const invDen =
        1 / (dot00 * dot11 - dot01 * dot01);

      const u =
        (dot11 * dot02 - dot01 * dot12) * invDen;

      const v =
        (dot00 * dot12 - dot01 * dot02) * invDen;

      return (
        u >= 0 &&
        v >= 0 &&
        u + v <= 1
      );
    }

    function segmentsIntersect(ax, ay, bx, by, cx, cy, dx, dy)
    {
      // robust segment intersection via orientation
      function orient(px, py, qx, qy, rx, ry)
      {
        return (qy - py) * (rx - qx) - (qx - px) * (ry - qy);
      }

      function onSeg(px, py, qx, qy, rx, ry)
      {
        return (
          Math.min(px, rx) <= qx && qx <= Math.max(px, rx) &&
          Math.min(py, ry) <= qy && qy <= Math.max(py, ry)
        );
      }

      const o1 = orient(ax, ay, bx, by, cx, cy);
      const o2 = orient(ax, ay, bx, by, dx, dy);
      const o3 = orient(cx, cy, dx, dy, ax, ay);
      const o4 = orient(cx, cy, dx, dy, bx, by);

      if (o1 === 0 && onSeg(ax, ay, cx, cy, bx, by)) return true;
      if (o2 === 0 && onSeg(ax, ay, dx, dy, bx, by)) return true;
      if (o3 === 0 && onSeg(cx, cy, ax, ay, dx, dy)) return true;
      if (o4 === 0 && onSeg(cx, cy, bx, by, dx, dy)) return true;

      return (o1 > 0) !== (o2 > 0) && (o3 > 0) !== (o4 > 0);
    }

    function rectIntersectsTriangle(rect, tri)
    {
      // tri = { ax,ay,bx,by,cx,cy }
      // 1) quick AABB check for triangle vs rect
      const minX =
        Math.min(tri.ax, tri.bx, tri.cx);

      const maxX =
        Math.max(tri.ax, tri.bx, tri.cx);

      const minY =
        Math.min(tri.ay, tri.by, tri.cy);

      const maxY =
        Math.max(tri.ay, tri.by, tri.cy);

      const triAabb =
      {
        x: minX,
        y: minY,
        w: maxX - minX,
        h: maxY - minY,
      };

      if (!rectsOverlap(rect, triAabb))
      {
        return false;
      }

      // 2) rect corners inside triangle
      const corners =
      [
        [rect.x, rect.y],
        [rect.x + rect.w, rect.y],
        [rect.x + rect.w, rect.y + rect.h],
        [rect.x, rect.y + rect.h],
      ];

      for (let i = 0; i < corners.length; i++)
      {
        const [px, py] = corners[i];

        if (pointInTriangle(px, py, tri.ax, tri.ay, tri.bx, tri.by, tri.cx, tri.cy))
        {
          return true;
        }
      }

      // 3) triangle vertices inside rect
      function pointInRect(px, py, r)
      {
        return (
          px >= r.x &&
          px <= r.x + r.w &&
          py >= r.y &&
          py <= r.y + r.h
        );
      }

      if (pointInRect(tri.ax, tri.ay, rect)) return true;
      if (pointInRect(tri.bx, tri.by, rect)) return true;
      if (pointInRect(tri.cx, tri.cy, rect)) return true;

      // 4) edge intersections (rect edges vs tri edges)
      const re =
      [
        // rect edges
        [rect.x, rect.y, rect.x + rect.w, rect.y],
        [rect.x + rect.w, rect.y, rect.x + rect.w, rect.y + rect.h],
        [rect.x + rect.w, rect.y + rect.h, rect.x, rect.y + rect.h],
        [rect.x, rect.y + rect.h, rect.x, rect.y],
      ];

      const te =
      [
        [tri.ax, tri.ay, tri.bx, tri.by],
        [tri.bx, tri.by, tri.cx, tri.cy],
        [tri.cx, tri.cy, tri.ax, tri.ay],
      ];

      for (let i = 0; i < re.length; i++)
      {
        for (let j = 0; j < te.length; j++)
        {
          if (segmentsIntersect(
            re[i][0], re[i][1], re[i][2], re[i][3],
            te[j][0], te[j][1], te[j][2], te[j][3]
          ))
          {
            return true;
          }
        }
      }

      return false;
    }

    /* =============================================================================
       Particles
       ============================================================================= */

    class Particle
    {
      constructor(x, y, vx, vy, life, size, kind)
      {
        this.x = x;
        this.y = y;

        this.vx = vx;
        this.vy = vy;

        this.life = life;
        this.lifeMax = life;

        this.size = size;

        this.kind = kind; // "trail" | "boom" | "spark"
        this.rot = rand(0, TAU);
        this.spin = rand(-8, 8);
      }

      update(dt)
      {
        this.life -= dt;

        this.x += this.vx * dt;
        this.y += this.vy * dt;

        // slight drag
        this.vx *= Math.pow(0.40, dt);
        this.vy *= Math.pow(0.40, dt);

        // gravity for some kinds
        if (this.kind !== "trail")
        {
          this.vy += 900 * dt;
        }

        this.rot += this.spin * dt;
      }

      draw(g, pulse)
      {
        const t =
          clamp(this.life / this.lifeMax, 0, 1);

        const a =
          t * (this.kind === "trail" ? 0.35 : 0.9);

        g.save();

        g.globalAlpha =
          a;

        g.translate(this.x, this.y);
        g.rotate(this.rot);

        const s =
          this.size * (0.65 + 0.55 * (1 - t));

        if (this.kind === "trail")
        {
          g.fillStyle =
            `rgba(125, 249, 255, ${1.25 * a})`; //intensity of each trail particle

          g.shadowBlur =
            32 + 18 * pulse; //trail spread distance

          g.shadowColor =
            "rgba(125, 249, 255, 0.6)";

          g.fillRect(-s * 0.5, -s * 0.5, s, s);
        }
        else
        {
          g.fillStyle =
            `rgba(255, 77, 255, ${0.85 * a})`;

          g.shadowBlur =
            22 + 18 * pulse;

          g.shadowColor =
            "rgba(255, 77, 255, 0.7)";

          g.fillRect(-s * 0.5, -s * 0.5, s, s);
        }

        g.restore();
      }
    }

    /* =============================================================================
       Obstacles
       ============================================================================= */

    class Obstacle
    {
      constructor(type, worldX, y, w, h, data)
      {
        this.type =
          type;   // "spike" | "block"

        this.worldX =
          worldX;

        this.y =
          y;

        this.w =
          w;

        this.h =
          h;

        this.data =
          data || {};
      }

      getScreenX(worldDist)
      {
        return (this.worldX - worldDist) + playerX;
      }

      draw(g, worldDist, pulse)
      {
        const sx =
          this.getScreenX(worldDist);

        if (sx + this.w < -200) return;
        if (sx > W + 200) return;

        if (this.type === "block")
        {
          // neon block
          g.save();

          const x = sx;
          const y = this.y;

          g.shadowBlur =
            18 + 12 * pulse;

          g.shadowColor =
            "rgba(124, 252, 154, 0.65)";

          // fill
          g.fillStyle =
            "rgba(10, 255, 150, 0.14)";

          g.fillRect(x, y, this.w, this.h);

          // outline
          g.lineWidth =
            2;

          g.strokeStyle =
            "rgba(124, 252, 154, 0.85)";

          g.strokeRect(x + 1, y + 1, this.w - 2, this.h - 2);

          // inner highlight
          g.lineWidth =
            1;

          g.strokeStyle =
            "rgba(255, 255, 255, 0.22)";

          g.strokeRect(x + 4, y + 4, this.w - 8, this.h - 8);

          g.restore();
        }
        else if (this.type === "spike")
        {
          // neon spike triangle
          const x = sx;
          const y = this.y;

          const ax = x;
          const ay = y + this.h;

          const bx = x + this.w * 0.5;
          const by = y;

          const cx = x + this.w;
          const cy = y + this.h;

          g.save();

          g.shadowBlur =
            18 + 14 * pulse;

          g.shadowColor =
            "rgba(255, 77, 255, 0.7)";

          g.beginPath();
          g.moveTo(ax, ay);
          g.lineTo(bx, by);
          g.lineTo(cx, cy);
          g.closePath();

          g.fillStyle =
            "rgba(255, 77, 255, 0.15)";

          g.fill();

          g.lineWidth =
            2;

          g.strokeStyle =
            "rgba(255, 77, 255, 0.9)";

          g.stroke();

          // tiny inner glow line
          g.lineWidth =
            1;

          g.strokeStyle =
            "rgba(255, 255, 255, 0.18)";

          g.beginPath();
          g.moveTo(ax + 4, ay - 2);
          g.lineTo(bx, by + 6);
          g.lineTo(cx - 4, cy - 2);
          g.stroke();

          g.restore();
        }
      }

      getCollisionShape(worldDist)
      {
        const sx =
          this.getScreenX(worldDist);

        if (this.type === "block")
        {
          return {
            kind: "rect",
            rect:
            {
              x: sx,
              y: this.y,
              w: this.w,
              h: this.h,
            }
          };
        }

        // spike triangle
        const tri =
        {
          ax: sx,
          ay: this.y + this.h,

          bx: sx + this.w * 0.5,
          by: this.y,

          cx: sx + this.w,
          cy: this.y + this.h,
        };

        // Optional: a smaller “fairness” rect to early-reject
        const inset =
          0.16;

        const fx =
          sx + this.w * inset;

        const fy =
          this.y + this.h * inset;

        const fw =
          this.w * (1 - inset * 2);

        const fh =
          this.h * (1 - inset);

        return {
          kind: "tri",
          tri,
          fairnessRect:
          {
            x: fx,
            y: fy,
            w: fw,
            h: fh,
          },
        };
      }
    }

    /* =============================================================================
       Player
       ============================================================================= */

    class Player
    {
      constructor()
      {
        this.reset();
      }

      reset()
      {
        this.size =
          CONFIG.playerSize;

        this.x =
          playerX;

        this.y =
          groundY - this.size;

        this.vy =
          0;

        this.onGround =
          true;

        this.coyote =
          0;

        this.jumpBuf =
          0;

        this.rot =
          0;

        this.trailAcc =
          0;

        this.dead =
          false;

        this.squish =
          0;

        this.squishV =
          0;
      }

      getRect()
      {
        // Fair AABB collision: treat as axis-aligned square (like classic GD)
        return {
          x: this.x,
          y: this.y,
          w: this.size,
          h: this.size,
        };
      }

      tryJump()
      {
        if (this.dead) return false;

        // jump allowed if on ground or within coyote time
        if (this.onGround || this.coyote > 0)
        {
          this.vy =
            -CONFIG.jumpSpeed;

          this.onGround =
            false;

          this.coyote =
            0;

          // squish effect
          this.squishV =
            -7.5;

          audio.sfxJump();

          return true;
        }

        return false;
      }

      update(dt, worldSpeed)
      {
        if (this.dead) return;

        // Update timers
        if (!this.onGround)
        {
          this.coyote =
            Math.max(0, this.coyote - dt);
        }

        this.jumpBuf =
          Math.max(0, this.jumpBuf - dt);

        // Input → buffer jump
        if (input.jumpPressed)
        {
          this.jumpBuf =
            CONFIG.jumpBuffer;
        }

        // Apply buffered jump if we can
        if (this.jumpBuf > 0)
        {
          if (this.onGround || this.coyote > 0)
          {
            const did =
              this.tryJump();

            if (did)
            {
              this.jumpBuf = 0;
            }
          }
        }

        // Physics
        this.vy +=
          CONFIG.gravity * dt;

        this.vy =
          Math.min(this.vy, CONFIG.maxFallSpeed);

        this.y +=
          this.vy * dt;

        // Ground collision
        const groundTop =
          groundY - this.size;

        if (this.y >= groundTop)
        {
          // landing
          if (!this.onGround)
          {
            // snap rotation toward nearest 90 deg
            // and do a small landing squish
            this.squishV =
              7.0;
          }

          this.y =
            groundTop;

          this.vy =
            0;

          this.onGround =
            true;

          this.coyote =
            CONFIG.coyoteTime;
        }
        else
        {
          if (this.onGround)
          {
            // leaving ground → enable coyote time
            this.coyote =
              CONFIG.coyoteTime;
          }

          this.onGround =
            false;
        }

        // Rotation (Geometry Dash style)
        if (!this.onGround)
        {
          const rotSpeed =
            CONFIG.rotPerSecond * (worldSpeed / CONFIG.baseSpeed);

          this.rot +=
            rotSpeed * dt;
        }
        else
        {
          // Smoothly snap rotation to nearest quarter-turn when grounded
          const snap =
            Math.round(this.rot / (Math.PI / 2)) * (Math.PI / 2);

          const diff =
            snap - this.rot;

          this.rot +=
            diff * clamp(CONFIG.rotSnapStrength * dt, 0, 1);
        }

        // Squish animation
        this.squishV +=
          (-this.squish * 28) * dt;

        this.squishV *=
          Math.pow(0.06, dt);

        this.squish +=
          this.squishV * dt;

        this.squish =
          clamp(this.squish, -0.22, 0.22);

        // Trail particles
        this.trailAcc +=
          CONFIG.trailRate * dt;

        while (this.trailAcc >= 1)
        {
          this.trailAcc -= 1;

          if (!this.onGround)
          {
            spawnTrailParticle(this.x + this.size * 0.15, this.y + this.size * 0.5);
          }
          else
          {
            // subtle trail even on ground (smaller)
            if (Math.random() < 0.25)
            {
              spawnTrailParticle(this.x + this.size * 0.15, this.y + this.size * 0.65, true);
            }
          }
        }
      }

      draw(g, pulse) 
      {
        const cx =
          this.x + this.size * 0.5;

        const cy =
          this.y + this.size * 0.5;

        g.save();

        g.translate(cx, cy);
        g.rotate(this.rot);

        // squish scale
        const sx =
          1 + this.squish * 0.9;

        const sy =
          1 - this.squish * 0.9;

        g.scale(sx, sy);

        // main cube
        g.shadowBlur =
          22 + 14 * pulse;

        g.shadowColor =
          "rgba(125, 249, 255, 0.75)";

        g.fillStyle =
          "rgba(125, 249, 255, 0.12)";

        g.fillRect(-this.size * 0.5, -this.size * 0.5, this.size, this.size);

        // outline
        g.lineWidth =
          2;

        g.strokeStyle =
          "rgba(125, 249, 255, 0.95)";

        g.strokeRect(-this.size * 0.5 + 1, -this.size * 0.5 + 1, this.size - 2, this.size - 2);

        // inner crisp edge
        g.lineWidth =
          1;

        g.strokeStyle =
          "rgba(255, 255, 255, 0.18)";

        g.strokeRect(-this.size * 0.5 + 5, -this.size * 0.5 + 5, this.size - 10, this.size - 10);

        g.restore();
      }
    }

    /* =============================================================================
       Background — parallax layers
       =============================================================================
       Strategy:
       - Use worldDistance as time-based scroll reference
       - Multiple layers with different parallax factors
       - Add moving grid + occasional neon “blocks” for vibe
       - Beat pulse factor modulates glow/brightness
       ============================================================================= */

    const stars =
      [];

    function initStars()
    {
      stars.length = 0;

      const count =
        140;

      for (let i = 0; i < count; i++)
      {
        stars.push(
          {
            wx: rand(-600, 3600),
            y: rand(40, H * 0.65),
            r: rand(0.8, 2.4),
            tw: rand(0.3, 1.2),
          }
        );
      }
    }

    initStars();

    function drawBackground(g, worldDist, pulse)
    {
      // Base gradient fill
      const grad =
        g.createLinearGradient(0, 0, 0, H);

      grad.addColorStop(0.0, "#070717");
      grad.addColorStop(0.55, "#08081a");
      grad.addColorStop(1.0, "#04040e");

      g.fillStyle = grad;
      g.fillRect(0, 0, W, H);

      // Far stars
      g.save();

      g.globalAlpha =
        0.95;

      for (let i = 0; i < stars.length; i++)
      {
        const s = stars[i];

        // Parallax factor
        const px =
          ((s.wx - worldDist * 0.05) % 4200 + 4200) % 4200;

        const x =
          px - 600;

        const tw =
          0.6 + 0.4 * Math.sin((worldTime * 2.2) + s.tw * 10);

        g.globalAlpha =
          0.22 * tw;

        g.beginPath();
        g.arc(x, s.y, s.r, 0, TAU);

        g.fillStyle =
          `rgba(255, 255, 255, ${0.55 + 0.25 * pulse})`;

        g.fill();
      }

      g.restore();

      // Mid “mountain” silhouettes (neon haze)
      drawNeonHills(g, worldDist, pulse);

      // Near grid overlay
      drawGrid(g, worldDist, pulse);

      // Ground haze
      g.save();

      g.globalAlpha =
        0.55;

      g.fillStyle =
        "rgba(125, 249, 255, 0.05)";

      g.fillRect(0, groundY, W, H - groundY);

      g.restore();
    }

    function drawNeonHills(g, worldDist, pulse)
    {
      const baseY =
        groundY - H * 0.28;

      const amp =
        26 + 10 * pulse;

      const period =
        340;

      // far layer
      g.save();

      g.globalAlpha =
        0.65;

      g.shadowBlur =
        18 + 18 * pulse;

      g.shadowColor =
        "rgba(255, 77, 255, 0.25)";

      g.beginPath();
      g.moveTo(0, groundY);

      for (let x = 0; x <= W; x += 18)
      {
        const wx =
          worldDist * 0.12 + x;

        const y =
          baseY +
          Math.sin(wx / period) * amp +
          Math.sin(wx / (period * 0.55)) * (amp * 0.35);

        g.lineTo(x, y);
      }

      g.lineTo(W, groundY);
      g.closePath();

      g.fillStyle =
        "rgba(255, 77, 255, 0.06)";

      g.fill();

      g.restore();

      // mid layer
      g.save();

      g.globalAlpha =
        0.85;

      g.shadowBlur =
        18 + 16 * pulse;

      g.shadowColor =
        "rgba(125, 249, 255, 0.25)";

      g.beginPath();
      g.moveTo(0, groundY);

      for (let x = 0; x <= W; x += 16)
      {
        const wx =
          worldDist * 0.18 + x;

        const y =
          baseY + 70 +
          Math.sin(wx / (period * 0.85)) * (amp * 0.9) +
          Math.sin(wx / (period * 0.42)) * (amp * 0.24);

        g.lineTo(x, y);
      }

      g.lineTo(W, groundY);
      g.closePath();

      g.fillStyle =
        "rgba(125, 249, 255, 0.045)";

      g.fill();

      g.restore();
    }

    function drawGrid(g, worldDist, pulse)
    {
      const spacing =
        46;

      const off =
        (worldDist * 0.65) % spacing;

      g.save();

      g.globalAlpha =
        0.25 + 0.08 * pulse;

      g.lineWidth =
        1;

      g.strokeStyle =
        "rgba(255, 255, 255, 0.10)";

      // vertical lines
      g.beginPath();

      for (let x = -off; x <= W + spacing; x += spacing)
      {
        g.moveTo(x, 0);
        g.lineTo(x, groundY);
      }

      // horizontal lines (lighter)
      for (let y = 40; y <= groundY; y += spacing)
      {
        g.moveTo(0, y);
        g.lineTo(W, y);
      }

      g.stroke();

      // occasional neon rectangles
      g.globalAlpha =
        0.08 + 0.06 * pulse;

      g.fillStyle =
        "rgba(255, 77, 255, 0.25)";

      const n =
        6;

      for (let i = 0; i < n; i++)
      {
        const x =
          ((i * 370) - (worldDist * 0.25) % 370) % (W + 370) - 90;

        const y =
          60 + (i * 43) % Math.max(120, groundY - 140);

        g.fillRect(x, y, 58, 10);
      }

      g.restore();
    }

    function drawGround(g, worldDist, pulse)
    {
      // ground line with glow
      g.save();

      g.shadowBlur =
        22 + 14 * pulse;

      g.shadowColor =
        "rgba(255, 211, 107, 0.55)";

      g.strokeStyle =
        "rgba(255, 211, 107, 0.95)";

      g.lineWidth =
        3;

      g.beginPath();
      g.moveTo(0, groundY);
      g.lineTo(W, groundY);
      g.stroke();

      // subtle texture “ticks”
      g.shadowBlur = 0;

      g.globalAlpha =
        0.28;

      g.strokeStyle =
        "rgba(255, 255, 255, 0.12)";

      g.lineWidth =
        1;

      const spacing =
        24;

      const off =
        (worldDist * 0.9) % spacing;

      g.beginPath();

      for (let x = -off; x <= W + spacing; x += spacing)
      {
        g.moveTo(x, groundY + 2);
        g.lineTo(x + 10, groundY + 2);
      }

      g.stroke();

      g.restore();
    }

    /* =============================================================================
       Obstacle generator (procedural + fair)
       =============================================================================
       We generate “patterns” rather than totally random singles so it feels more
       like a real GD level:
       - single spike
       - double spike
       - triple spike
       - block
       - block + spike
       - spike + block
       All patterns are spaced with a gap that depends on difficulty & speed.
       ============================================================================= */

    class PatternGenerator
    {
      constructor()
      {
        this.reset();
      }

      reset()
      {
        this.spawnCursor =
          0; // world X where next pattern begins

        this.lastPattern =
          "";
      }

      seedInitial(worldDist)
      {
        this.spawnCursor =
          worldDist + 600;
      }

      getDifficulty01(speed)
      {
        return clamp(
          (speed - CONFIG.baseSpeed) / (CONFIG.maxSpeed - CONFIG.baseSpeed),
          0,
          1
        );
      }

      spawnUntil(obstacles, worldDist, speed)
      {
        const limit =
          worldDist + CONFIG.spawnAhead;

        while (this.spawnCursor < limit)
        {
          this.spawnPattern(obstacles, speed);
        }
      }

      spawnPattern(obstacles, speed)
      {
        const diff =
          this.getDifficulty01(speed);

        const gap =
          lerp(CONFIG.maxGap, CONFIG.minGap, diff) + rand(-60, 60);

        const choice =
          this.choosePattern(diff);

        const baseY =
          groundY;

        let length =
          0;

        if (choice === "S1")
        {
          const w = CONFIG.spikeWidth;
          const h = CONFIG.spikeHeight;

          obstacles.push(
            new Obstacle(
              "spike",
              this.spawnCursor,
              baseY - h,
              w,
              h
            )
          );

          length = w;
        }
        else if (choice === "S2")
        {
          const w = CONFIG.spikeWidth;
          const h = CONFIG.spikeHeight;

          obstacles.push(new Obstacle("spike", this.spawnCursor, baseY - h, w, h));
          obstacles.push(new Obstacle("spike", this.spawnCursor + w * 0.95, baseY - h, w, h));

          length = w * 2;
        }
        else if (choice === "S3")
        {
          const w = CONFIG.spikeWidth;
          const h = CONFIG.spikeHeight;

          obstacles.push(new Obstacle("spike", this.spawnCursor, baseY - h, w, h));
          obstacles.push(new Obstacle("spike", this.spawnCursor + w * 0.95, baseY - h, w, h));
          obstacles.push(new Obstacle("spike", this.spawnCursor + w * 1.90, baseY - h, w, h));

          length = w * 3;
        }
        else if (choice === "B1")
        {
          const size =
            randInt(CONFIG.blockMin, CONFIG.blockMax);

          obstacles.push(
            new Obstacle(
              "block",
              this.spawnCursor,
              baseY - size,
              size,
              size
            )
          );

          length = size;
        }
        else if (choice === "BS")
        {
          const size =
            randInt(CONFIG.blockMin, CONFIG.blockMax);

          const w = CONFIG.spikeWidth;
          const h = CONFIG.spikeHeight;

          obstacles.push(
            new Obstacle(
              "block",
              this.spawnCursor,
              baseY - size,
              size,
              size
            )
          );

          obstacles.push(
            new Obstacle(
              "spike",
              this.spawnCursor + size + lerp(70, 44, diff),
              baseY - h,
              w,
              h
            )
          );

          length =
            size + 140;
        }
        else if (choice === "SB")
        {
          const w = CONFIG.spikeWidth;
          const h = CONFIG.spikeHeight;

          const size =
            randInt(CONFIG.blockMin, CONFIG.blockMax);

          obstacles.push(
            new Obstacle(
              "spike",
              this.spawnCursor,
              baseY - h,
              w,
              h
            )
          );

          obstacles.push(
            new Obstacle(
              "block",
              this.spawnCursor + w + lerp(80, 50, diff),
              baseY - size,
              size,
              size
            )
          );

          length =
            w + 160;
        }
        else
        {
          // fallback
          const w = CONFIG.spikeWidth;
          const h = CONFIG.spikeHeight;

          obstacles.push(
            new Obstacle(
              "spike",
              this.spawnCursor,
              baseY - h,
              w,
              h
            )
          );

          length = w;
        }

        // Push spawn cursor forward
        this.spawnCursor +=
          length + gap;

        this.lastPattern =
          choice;
      }

      choosePattern(diff)
      {
        // Easy → mostly single spikes and blocks
        // Hard → more doubles/triples and mixed patterns
        const r =
          Math.random();

        if (diff < 0.25)
        {
          if (r < 0.45) return "S1";
          if (r < 0.75) return "B1";
          if (r < 0.88) return "SB";
          return "BS";
        }

        if (diff < 0.60)
        {
          if (r < 0.28) return "S1";
          if (r < 0.52) return "S2";
          if (r < 0.72) return "B1";
          if (r < 0.86) return "SB";
          return "BS";
        }

        // late game
        if (r < 0.18) return "S1";
        if (r < 0.42) return "S2";
        if (r < 0.62) return "S3";
        if (r < 0.75) return "B1";
        if (r < 0.88) return "SB";
        return "BS";
      }
    }

    /* =============================================================================
       Game state
       ============================================================================= */

    const STATE =
    {
      MENU: "MENU",
      PLAYING: "PLAYING",
      GAMEOVER: "GAMEOVER",
    };

    let state =
      STATE.MENU;

    const player =
      new Player();

    const obstacles =
      [];

    const particles =
      [];

    const generator =
      new PatternGenerator();

    let worldDist =
      0;

    let worldSpeed =
      CONFIG.baseSpeed;

    let runTime =
      0;

    let score =
      0;

    let bestScore =
      0;

    let milestone =
      0;

    // score checkpoint celebration state
    let checkpointTarget =
      100;

    // set to true when this run beats the stored best (used for GAME OVER celebration)
    let newBestThisRun =
      false;

    let shakeT =
      0;

    let shakeMag =
      0;

    let worldTime =
      0;

    // beat phase (for pulse)
    let beatPhase =
      0;

    // fixed timestep accumulator
    let lastFrameT =
      0;

    let accumulator =
      0;

    /* =============================================================================
       Storage
       ============================================================================= */

    function loadBest()
    {
      const v =
        localStorage.getItem("neon_dash_best");

      bestScore =
        v ? parseInt(v, 10) : 0;

      if (!Number.isFinite(bestScore)) bestScore = 0;

      uiBest.textContent =
        bestScore.toString();
    }

    function saveBest()
    {
      localStorage.setItem("neon_dash_best", String(bestScore));
      uiBest.textContent = bestScore.toString();
    }

    let lastScore = 0;

    function loadLast()
    {
      const v =
        localStorage.getItem("neon_dash_last");

      lastScore =
        v ? parseInt(v, 10) : 0;

      if (!Number.isFinite(lastScore)) lastScore = 0;

      uiLast.textContent =
        lastScore.toString();
    }

    function saveLast(v)
    {
      lastScore = v;

      localStorage.setItem(
        "neon_dash_last",
        String(lastScore)
      );

      uiLast.textContent =
        lastScore.toString();
    }

    loadBest();
    loadLast();


    /* =============================================================================
       Particle spawners
       ============================================================================= */

    function spawnTrailParticle(x, y, small)
    {
      const p =
        new Particle(
          x + rand(-2, 2),
          y + rand(-2, 2),
          rand(-90, -220),
          rand(-30, 80),
          small ? rand(0.14, 0.22) : rand(0.18, 0.32),
          small ? rand(6, 10) : rand(8, 13),
          "trail"
        );

      particles.push(p);
    }

    function spawnDeathExplosion(x, y)
    {
      for (let i = 0; i < CONFIG.deathParticles; i++)
      {
        const a =
          rand(0, TAU);

        const sp =
          rand(220, 1200);

        const vx =
          Math.cos(a) * sp;

        const vy =
          Math.sin(a) * sp - rand(0, 260);

        particles.push(
          new Particle(
            x + rand(-6, 6),
            y + rand(-6, 6),
            vx,
            vy,
            rand(0.35, 0.72),
            rand(8, 16),
            "boom"
          )
        );
      }
    }


    /* =============================================================================
       Score celebrations (Checkpoint flames + Best-score prestige)
       ============================================================================= */

    // Fixed checkpoints (once per run). After 1000: every +250.
    const CHECKPOINTS =
      [100, 300, 500, 750, 1000];

    const CHECKPOINT_SFX_URLS =
    {
      100: "./static/Apple_pay.mp3",
      300: "./static/Apple_pay.mp3",
      500: "./static/Apple_pay.mp3",
      750: "./static/Apple_pay.mp3",
      1000: "./static/Apple_pay.mp3",
    };

    // MP3 played when a new best score is achieved (GAME OVER screen)
    const BEST_SCORE_SFX_URL = "./static/best_score.mp3";


    const CHECKPOINT_PALETTES =
    {
      100: { outer: "#ff4f1a", mid: "#ffb300", inner: "#fff3c2", glow: "#ffd36b" },
      300: { outer: "#ff1f7b", mid: "#ff6ad5", inner: "#fff0fb", glow: "#ff9be6" },
      500: { outer: "#00b8ff", mid: "#63f6ff", inner: "#e9feff", glow: "#9efcff" },
      750: { outer: "#20ff6b", mid: "#9effb9", inner: "#eafff0", glow: "#b7ffd1" },
      1000:{ outer: "#ffb000", mid: "#ffe066", inner: "#fff6d6", glow: "#fff0a8" },
    };

    function hexToRgb(hex)
    {
      const h = hex.replace("#", "");
      const n = parseInt(h.length === 3 ? h.split("").map(c => c + c).join("") : h, 16);
      return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 };
    }

    function rgbToHex(r, g, b)
    {
      const to = (v) => v.toString(16).padStart(2, "0");
      return "#" + to(r) + to(g) + to(b);
    }

    function shadeHex(hex, amt)
    {
      // amt in [-1..1] (negative = darker, positive = lighter)
      const c = hexToRgb(hex);
      const t = amt >= 0 ? 255 : 0;
      const p = Math.min(1, Math.abs(amt));
      const r = Math.round(c.r + (t - c.r) * p);
      const g = Math.round(c.g + (t - c.g) * p);
      const b = Math.round(c.b + (t - c.b) * p);
      return rgbToHex(r, g, b);
    }

    function jitterPalette(pal)
    {
      const j = rand(-0.10, 0.14);
      return {
        outer: shadeHex(pal.outer, j),
        mid: shadeHex(pal.mid, j * 0.6),
        inner: shadeHex(pal.inner, j * 0.35),
        glow: shadeHex(pal.glow, j * 0.55),
      };
    }

    function nextCheckpointValue(cp)
    {
      const idx = CHECKPOINTS.indexOf(cp);
      if (idx !== -1 && idx < CHECKPOINTS.length - 1)
      {
        return CHECKPOINTS[idx + 1];
      }

      // After 1000: every 250
      if (cp >= 1000) return cp + 250;

      // fallback
      return 1000;
    }

    function easeOutBack(x)
    {
      const c1 = 1.70158;
      const c3 = c1 + 1;
      return 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2);
    }

    function easeOutCubic(x)
    {
      return 1 - Math.pow(1 - x, 3);
    }

    function pixelText(ctx, txt, x, y, size, fillA, fillB, alpha)
    {
      ctx.save();
      ctx.globalAlpha = alpha;

      // "pixel-ish" outline by stamping 4 directions
      ctx.font =
        `900 ${size}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace`;

      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillText(txt, x - 2, y);
      ctx.fillText(txt, x + 2, y);
      ctx.fillText(txt, x, y - 2);
      ctx.fillText(txt, x, y + 2);

      // gradient fill (white→goldy) but still "arcade"
      const g = ctx.createLinearGradient(x - 60, y - 18, x + 60, y + 18);
      g.addColorStop(0, fillA);
      g.addColorStop(1, fillB);

      ctx.fillStyle = g;
      ctx.fillText(txt, x, y);

      ctx.restore();
    }

    class FlameParticle
    {
      constructor(x, y, vx, vy, life, size, col)
      {
        this.x = x; this.y = y;
        this.vx = vx; this.vy = vy;
        this.life = life;
        this.t = 0;
        this.size = size;
        this.col = col;
      }

      update(dt)
      {
        this.t += dt;
        // slightly float + drag
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.vx *= Math.pow(0.12, dt);
        this.vy *= Math.pow(0.22, dt);
        this.vy -= 18 * dt; // keep rising
      }

      draw(ctx)
      {
        const p = clamp(this.t / this.life, 0, 1);
        const a = (1 - p) * (1 - p);
        const s = this.size;

        ctx.globalAlpha = a;
        ctx.fillStyle = this.col;
        ctx.fillRect(Math.round(this.x - s * 0.5), Math.round(this.y - s * 0.5), s, s);
      }

      alive()
      {
        return this.t < this.life;
      }
    }

    class CheckpointBurst
    {
      constructor(scoreValue, intensity, palette, duration)
      {
        this.scoreValue = scoreValue;
        this.intensity = intensity;
        this.palette = palette;
        this.duration = duration;

        this.t = 0;
        this.seed = rand(0, 99999);

        // anchor near top-centre; keep clear of HUD
        this.x = W * 0.5;
        this.y = Math.max(250, 14 + 86); //position of the flame effect

        this.particles = [];

        const baseCount = Math.floor(26 + 50 * intensity);
        for (let i = 0; i < baseCount; i++)
        {
          this.spawnParticle(0, 0, true);
        }
      }

      spawnParticle(dx, dy, fast)
      {
        const sp = fast ? rand(80, 220) : rand(30, 140);
        const ang = rand(-Math.PI * 0.85, -Math.PI * 0.15);
        const vx = Math.cos(ang) * sp * rand(0.35, 1.0);
        const vy = Math.sin(ang) * sp * rand(0.55, 1.0);

        const col = rand() < 0.55 ? this.palette.mid : this.palette.glow;
        const size = rand(2, 4) + Math.floor(this.intensity);
        const life = rand(0.35, 0.85) + this.intensity * 0.12;

        this.particles.push(
          new FlameParticle(
            this.x + dx,
            this.y + dy,
            vx,
            vy,
            life,
            size,
            col
          )
        );
      }

      update(dt)
      {
        this.t += dt;

        // keep spawning a few flicker sparks early
        if (this.t < this.duration * 0.45 && rand() < 0.45)
        {
          const w = 18 + 10 * this.intensity;
          this.spawnParticle(rand(-w, w), rand(-10, 6), false);
        }

        for (let i = this.particles.length - 1; i >= 0; i--)
        {
          this.particles[i].update(dt);
          if (!this.particles[i].alive()) this.particles.splice(i, 1);
        }
      }

      draw(ctx)
      {
        const p = clamp(this.t / this.duration, 0, 1);

        const pop = easeOutBack(clamp(p / 0.18, 0, 1));
        const fade = 1 - clamp((p - 0.72) / 0.28, 0, 1);

        const lift = -30 * easeOutCubic(p);
        const wobble = Math.sin(this.t * (10 + 3 * this.intensity) + this.seed) * (2 + 1.2 * this.intensity);

        const scale = (0.92 + 0.40 * pop) * (1 + 0.02 * wobble); // overall scale

        const px = 3; // pixel step

        ctx.save();
        ctx.globalAlpha = fade;

        // subtle glow bloom (still pixel-y)
        ctx.globalAlpha = fade * 0.22;
        ctx.fillStyle = this.palette.glow;
        const glowW = (110 + 48 * this.intensity);
        ctx.fillRect(
          Math.round(this.x - glowW * 0.5),
          Math.round(this.y - 64 + lift),
          Math.round(glowW),
          Math.round(18)
        );

        ctx.globalAlpha = fade;

        // flame columns
        ctx.save();
        ctx.translate(Math.round(this.x), Math.round(this.y + lift));
        ctx.scale(scale, scale);

        // base dimensions
        const baseW = 120 + 70 * this.intensity;
        const baseH = 62  + 34 * this.intensity;

        const cols = Math.floor(baseW / px);
        const half = cols * 0.5;

        for (let i = 0; i < cols; i++)
        {
          const x = (i - half) * px;

          // flame height with flicker
          const n = (Math.sin((i * 0.55) + this.t * (18 + 2 * this.intensity) + this.seed) + 1) * 0.5;
          const edge = 1 - Math.abs((i - half) / half);
          const h = (baseH * (0.26 + 0.86 * n) * (0.55 + 0.45 * edge)) * (1 - 0.18 * p);

          const h1 = Math.max(6, h);
          const h2 = Math.max(4, h * 0.72);
          const h3 = Math.max(3, h * 0.48);

          // outer
          ctx.fillStyle = this.palette.outer;
          ctx.fillRect(Math.round(x), 0, px, -Math.round(h1));

          // mid
          ctx.fillStyle = this.palette.mid;
          ctx.fillRect(Math.round(x), 0, px, -Math.round(h2));

          // inner (leave gaps so it feels like pixels)
          if (i % 2 === 0)
          {
            ctx.fillStyle = this.palette.inner;
            ctx.fillRect(Math.round(x), 0, px, -Math.round(h3));
          }
        }

        // a few bright "embers" on top
        ctx.fillStyle = this.palette.glow;
        for (let k = 0; k < 14 + 8 * this.intensity; k++)
        {
          const ex = rand(-baseW * 0.45, baseW * 0.45);
          const ey = -rand(baseH * 0.25, baseH * 1.05);
          if (rand() < 0.6) ctx.fillRect(Math.round(ex), Math.round(ey), px, px);
        }

        // text (on top of flame)
        const label = `${this.scoreValue}!`;
        pixelText(ctx, label, 0, -baseH - 15, 34 + Math.floor(7 * this.intensity), "#ffffff", this.palette.glow, 1);

        ctx.restore();

        // particles (screen space)
        for (let i = 0; i < this.particles.length; i++)
        {
          this.particles[i].draw(ctx);
        }

        ctx.restore();
      }

      alive()
      {
        return this.t < this.duration || this.particles.length > 0;
      }
    }

    class BestScoreBurst
    {
      constructor()
      {
        this.t = 0;
        this.duration = 2.6;

        this.particles = [];

        // centre-ish; behind overlay panel
        this.x = W * 0.5;
        this.y = H * 0.42;

        for (let i = 0; i < 160; i++)
        {
          const ang = rand(0, Math.PI * 2);
          const sp = rand(70, 260);
          const vx = Math.cos(ang) * sp;
          const vy = Math.sin(ang) * sp;

          const life = rand(0.6, 1.35);
          const size = rand(2, 4);
          const col = rand() < 0.5 ? "#ffe066" : "#fff6d6";

          this.particles.push(new FlameParticle(this.x, this.y, vx, vy, life, size, col));
        }
      }

      update(dt)
      {
        this.t += dt;
        for (let i = this.particles.length - 1; i >= 0; i--)
        {
          this.particles[i].update(dt);
          if (!this.particles[i].alive()) this.particles.splice(i, 1);
        }
      }

      draw(ctx)
      {
        const p = clamp(this.t / this.duration, 0, 1);
        const a = 1 - p;

        ctx.save();
        ctx.globalAlpha = a * 0.18;
        ctx.fillStyle = "#ffe066";
        ctx.fillRect(Math.round(this.x - 220), Math.round(this.y - 90), 440, 130);

        ctx.globalAlpha = a;
        for (let i = 0; i < this.particles.length; i++)
        {
          this.particles[i].draw(ctx);
        }

        ctx.restore();
      }

      alive()
      {
        return this.t < this.duration || this.particles.length > 0;
      }
    }

    class CelebrationSystem
    {
      constructor()
      {
        this.active =
          [];
      }

      reset()
      {
        this.active.length = 0;
      }

      spawnCheckpoint(cp)
      {
        let pal =
          CHECKPOINT_PALETTES[cp];

        // After 1000: randomised colours, still consistent with palette
        if (!pal)
        {
          const keys = Object.keys(CHECKPOINT_PALETTES);
          const pick = CHECKPOINT_PALETTES[keys[Math.floor(rand(0, keys.length))]];
          pal = jitterPalette(pick);
        }

        const intensity =
          cp <= 1000
            ? clamp(0.95 + cp / 520, 0.95, 2.55)
            : clamp(2.05 + (cp - 1000) / 2200, 2.05, 3.20);

        const duration =
          cp < 300 ? 0.95
            : cp < 750 ? 1.10
            : cp < 1000 ? 1.22
            : 1.30;

        this.active.push(
          new CheckpointBurst(cp, intensity, pal, duration)
        );
      }

      spawnBestScore()
      {
        this.active.push(new BestScoreBurst());
      }

      update(dt)
      {
        for (let i = this.active.length - 1; i >= 0; i--)
        {
          this.active[i].update(dt);
          if (!this.active[i].alive()) this.active.splice(i, 1);
        }
      }

      draw(ctx)
      {
        for (let i = 0; i < this.active.length; i++)
        {
          this.active[i].draw(ctx);
        }
      }
    }

    const celebrations =
      new CelebrationSystem();

    /* =============================================================================
       State transitions
       ============================================================================= */

    function setState(next)
    {
      state = next;

      // default: hide best-score panel; we'll enable it on GAMEOVER if this run beats bestScore
      bestScorePanel.classList.add("hidden");
      bestScorePanel.classList.remove("show");
      bestScorePanel.setAttribute("aria-hidden", "true");

      uiState.textContent =
        next;

      if (next === STATE.MENU)
      {
        overlay.classList.remove("hidden");

        btnStart.style.display =
          "inline-block";

        btnRestart.style.display =
          "none";

        panelTitle.textContent =
          "NEON DASH";

        panelSubtitle.textContent =
          "Geometry-Dash-style rhythm runner";

        panelText.innerHTML =
          "Press <b>Start</b> to start.<br/>Time your jumps. One hit = boom.";
        musicPanel.style.display = "block";
        btnPreview.textContent = "Preview";

        audio.stopMusic();
      }
      else if (next === STATE.PLAYING)
      {
        overlay.classList.add("hidden");
        audio.startMusic();
        musicPanel.style.display = "none";
      }
    else if (next === STATE.GAMEOVER)
    {
        overlay.classList.remove("hidden");

        btnStart.style.display = "none";
        btnRestart.style.display = "inline-block";

        panelTitle.textContent = "GAME OVER";
        panelSubtitle.textContent = "Press R / Tap to restart";

        panelText.innerHTML =
            `Score: <b>${Math.floor(score)}</b><br/>Best: <b>${bestScore}</b><br/>Press <b>R</b> or <b>Tap</b> to restart.`;

        // BEST SCORE celebration (rare + prestigious)
        if (newBestThisRun)
        {
          bestScoreValueEl.textContent =
            String(bestScore);

          bestScorePanel.classList.remove("hidden");
          bestScorePanel.setAttribute("aria-hidden", "false");

          // restart CSS animation
          bestScorePanel.classList.remove("show");
          void bestScorePanel.offsetWidth;
          bestScorePanel.classList.add("show");

          // play new-best-score MP3 (blocks jump-to-restart until it finishes; Restart/R can skip)
          audio.playBestScoreMp3(BEST_SCORE_SFX_URL, 0.95);
        }

        // show music settings on defeat page too
        musicPanel.style.display = "block";
        btnPreview.textContent = "Preview";

        audio.stopMusic();
        resetBestScoreBadgeAnim();
    }
    }

    function startFromMenu()
    {
      if (state !== STATE.MENU) return;

      restartRun();
      setState(STATE.PLAYING);
    }

    function restartRun()
    {
      // stop any best-score jingle so Restart can skip it
      audio.stopBestScoreMp3();
      // reset everything
      obstacles.length = 0;
      particles.length = 0;

      player.reset();

      worldDist = 0;
      runTime = 0;

      worldSpeed = CONFIG.baseSpeed;

      score = 0;
      milestone = 0;

      checkpointTarget =
        100;

      newBestThisRun =
        false;

      celebrations.reset();

      shakeT = 0;
      shakeMag = 0;

      generator.reset();
      generator.seedInitial(worldDist);

      // pre-spawn enough obstacles so it feels continuous
      generator.spawnUntil(obstacles, worldDist, worldSpeed);

      setState(STATE.PLAYING);
    }

    // pointer unlock audio (DO NOT auto-start the game)
    window.addEventListener("pointerdown", async () =>
    {
      await audio.unlock();
    }, { passive: true });

    function killPlayer()
    {
      if (state !== STATE.PLAYING) return;
      if (player.dead) return;

      player.dead = true;

      // explosion
      spawnDeathExplosion(
        player.x + player.size * 0.5,
        player.y + player.size * 0.5
      );

      // screen shake
      shakeT =
        CONFIG.shakeTime;

      shakeMag =
        CONFIG.shakeMag;

      audio.sfxDeath();

      // best score check
      const final =
        Math.floor(score);

      saveLast(final);

      newBestThisRun =
        final > bestScore;

      if (newBestThisRun)
      {
        bestScore = final;
        saveBest();

        // prestigious sparkle burst behind the GAME OVER panel
        celebrations.spawnBestScore();
      }

      setState(STATE.GAMEOVER);
    }

    // =============================================================================
    // Best-score crown zoom (only while best-score MP3 is playing)
    // =============================================================================
    let badgePulseTime = 0;
    let badgeCycle = 0;

    let badgeBaseScale = 1;       // grows every pulse
    let badgeScale = 1;           // actual applied scale

    let badgeWasPlaying = false;

    // smooth settle when MP3 ends (or user skips via Restart)
    let badgeSettleT = 0;
    let badgeSettleFrom = 1;
    let badgeSettleTo = 1;
    const badgeSettleDur = 0.32;  // seconds

    // tuning
    const BADGE_PULSES_PER_SEC = 2.4;  // pulses per second
    const BADGE_PULSE_AMP = 0.18;      // pulse strength
    const BADGE_GROW_PER_PULSE = 0.04; // growth added each completed pulse

    function badgeApplyScale(s)
    {
      if (!bestScoreBadgeEl) return;
      bestScoreBadgeEl.style.setProperty("--badgeScale", String(s));
    }

    function easeInOutSmooth(t)
    {
      // smoothstep
      return t * t * (3 - 2 * t);
    }

    function easeOutCubic(t)
    {
      return 1 - Math.pow(1 - t, 3);
    }

    function resetBestScoreBadgeAnim()
    {
      badgePulseTime = 0;
      badgeCycle = 0;
      badgeBaseScale = 1;
      badgeScale = 1;
      badgeWasPlaying = false;

      badgeSettleT = 0;
      badgeSettleFrom = 1;
      badgeSettleTo = 1;

      badgeApplyScale(1);
    }

    function updateBestScoreBadgeAnim(dt)
    {
      if (!bestScoreBadgeEl) return;

      // Only animate when the best-score panel is visible
      const panelVisible = !bestScorePanel.classList.contains("hidden");
      if (!panelVisible)
      {
        resetBestScoreBadgeAnim();
        return;
      }

      // This MUST match your audio manager function name:
      const playing = audio.isBestScoreMp3Playing();

      if (playing)
      {
        // advance pulse timer
        badgePulseTime += dt;

        // number of cycles completed
        const cyclesFloat = badgePulseTime * BADGE_PULSES_PER_SEC;
        const cyclesNow = Math.floor(cyclesFloat);

        // each completed cycle grows the base scale
        while (badgeCycle < cyclesNow)
        {
          badgeCycle++;
          badgeBaseScale += BADGE_GROW_PER_PULSE;
        }

        // phase 0..1 within current cycle
        const phase = cyclesFloat - cyclesNow;

        // triangle wave (0..1..0)
        let tri = phase < 0.5 ? (phase / 0.5) : ((1 - phase) / 0.5);
        tri = easeInOutSmooth(tri);

        // zoom around a growing base
        badgeScale = badgeBaseScale * (1 + BADGE_PULSE_AMP * tri);

        badgeApplyScale(badgeScale);

        // cancel any settling
        badgeSettleT = 0;
        badgeWasPlaying = true;
        return;
      }

      // if MP3 JUST stopped: smoothly settle to the final "zoom peak"
      if (badgeWasPlaying)
      {
        badgeWasPlaying = false;
        badgeSettleT = 0;

        badgeSettleFrom = badgeScale;
        badgeSettleTo = badgeBaseScale * (1 + BADGE_PULSE_AMP); // peak

        return;
      }

      // settle in progress
      if (badgeSettleT < badgeSettleDur)
      {
        badgeSettleT += dt;
        const t = Math.min(1, badgeSettleT / badgeSettleDur);
        const e = easeOutCubic(t);

        const s = badgeSettleFrom + (badgeSettleTo - badgeSettleFrom) * e;
        badgeScale = s;
        badgeApplyScale(s);
      }
    }
    /* =============================================================================
       Main update (fixed timestep)
       ============================================================================= */
    function update(dt)
    {
      worldTime += dt;

      // update celebration FX (also runs in MENU/GAMEOVER so animations can finish)
      celebrations.update(dt);

      // UI timers
      if (toastTimer > 0)
      {
        toastTimer -= dt;

        if (toastTimer <= 0)
        {
          toast.classList.add("hidden");
        }
      }

      // Beat pulse phase
      beatPhase +=
        dt * (CONFIG.bpm / 60);

      // keep in a manageable range
      if (beatPhase > 1e6) beatPhase -= 1e6;

      // pulsing factor for visuals (0..1)
      // Use a smooth “thump” shape.
      // phaseFrac is [0..1)
      const phaseFrac =
        beatPhase % 1;

      // We'll compute pulse in render; but audio uses scheduling too.
      audio.tickMusic();

      if (state !== STATE.PLAYING)
      {
        // still update particles for polish
        for (let i = particles.length - 1; i >= 0; i--)
        {
          particles[i].update(dt);
          if (particles[i].life <= 0) particles.splice(i, 1);
        }

        // allow tap to restart after deathF
        if (state === STATE.GAMEOVER)
        {
          updateBestScoreBadgeAnim(dt);
          const blockJump =
            audio.isBestScoreMp3Playing();

          // While the new-best MP3 is playing, ignore jump-to-restart.
          // "Restart" (R/button) still works and will skip the MP3.
          if (input.restartPressed || (input.jumpPressed && !blockJump))
          {
            restartRun();
          }
        }

        // allow start from menu via jump
        if (state === STATE.MENU)
        {
          if (input.jumpPressed)
          {
            startFromMenu();
          }
        }

        return;
      }

      // Difficulty ramp: speed increases slowly with run time
      runTime += dt;

      worldSpeed +=
        CONFIG.speedRampPerSec * dt;

      worldSpeed =
        Math.min(worldSpeed, CONFIG.maxSpeed);

      // score increases with distance
      score +=
        worldSpeed * dt * CONFIG.scorePerUnit;

      // checkpoint celebrations:
      // 100 / 300 / 500 / 750 / 1000 (once per run), then every +250 after 1000
      const scoreInt =
        Math.floor(score);

      while (scoreInt >= checkpointTarget)
      {
        celebrations.spawnCheckpoint(checkpointTarget);
        audio.sfxCheckpoint(checkpointTarget);

        checkpointTarget =
          nextCheckpointValue(checkpointTarget);
      }

      // advance world distance
      worldDist +=
        worldSpeed * dt;

      // player physics + input
      player.update(dt, worldSpeed);

      // spawn obstacles ahead
      generator.spawnUntil(obstacles, worldDist, worldSpeed);

      // collision checks
      const pr =
        player.getRect();

      // Slightly shrink player rect for fairness
      const inset =
        6;

      const prFair =
      {
        x: pr.x + inset,
        y: pr.y + inset,
        w: pr.w - inset * 2,
        h: pr.h - inset * 2,
      };

      for (let i = 0; i < obstacles.length; i++)
      {
        const o =
          obstacles[i];

        const shape =
          o.getCollisionShape(worldDist);

        if (shape.kind === "rect")
        {
          if (rectsOverlap(prFair, shape.rect))
          {
            killPlayer();
            break;
          }
        }
        else if (shape.kind === "tri")
        {
          // early reject using fairness rect for spike
          if (!rectsOverlap(prFair, shape.fairnessRect))
          {
            continue;
          }

          if (rectIntersectsTriangle(prFair, shape.tri))
          {
            killPlayer();
            break;
          }
        }
      }

      // remove far-behind obstacles (world coords)
      while (obstacles.length > 0)
      {
        const o0 =
          obstacles[0];

        const sx =
          o0.getScreenX(worldDist);

        if (sx + o0.w < -320)
        {
          obstacles.shift();
        }
        else
        {
          break;
        }
      }

      // screen shake decay
      if (shakeT > 0)
      {
        shakeT -= dt;

        if (shakeT < 0) shakeT = 0;
      }

      // update particles
      for (let i = particles.length - 1; i >= 0; i--)
      {
        particles[i].update(dt);
        if (particles[i].life <= 0) particles.splice(i, 1);
      }
    }

    /* =============================================================================
       Render
       ============================================================================= */

    function computePulse()
    {
      const f =
        beatPhase % 1;

      // pulse shape: quick rise, slow fall
      const thump =
        Math.exp(-f * 6.5) * Math.sin(f * Math.PI);

      return clamp(thump * 2.0, 0, 1);
    }

    function render()
    {
      const pulse =
        computePulse();

      // clear
      ctx.clearRect(0, 0, W, H);

      // screen shake transform
      let sx = 0;
      let sy = 0;

      if (shakeT > 0)
      {
        const t =
          shakeT / CONFIG.shakeTime;

        const mag =
          shakeMag * t;

        sx =
          rand(-mag, mag);

        sy =
          rand(-mag, mag);
      }

      ctx.save();
      ctx.translate(sx, sy);

      // background layers
      drawBackground(ctx, worldDist, pulse);

      // obstacles
      for (let i = 0; i < obstacles.length; i++)
      {
        obstacles[i].draw(ctx, worldDist, pulse);
      }

      // ground
      drawGround(ctx, worldDist, pulse);

      // particles (behind player looks better)
      for (let i = 0; i < particles.length; i++)
      {
        particles[i].draw(ctx, pulse);
      }

      // player
      player.draw(ctx, pulse);

      ctx.restore();

      // score celebrations (top-of-screen, non-blocking)
      celebrations.draw(ctx);

      // UI text updates
      uiScore.textContent =
        Math.floor(score).toString();

      uiBest.textContent =
        bestScore.toString();

      const speedMult =
        worldSpeed / CONFIG.baseSpeed;

      uiSpeed.textContent =
        speedMult.toFixed(2) + "x";
    }

    /* =============================================================================
       Main loop (requestAnimationFrame + fixed timestep)
       ============================================================================= */

    function frame(tMs)
    {
      const t =
        tMs * 0.001;

      if (!lastFrameT)
      {
        lastFrameT = t;
      }

      let dt =
        t - lastFrameT;

      lastFrameT = t;

      dt =
        clamp(dt, 0, CONFIG.maxFrameDt);

      accumulator += dt;

      while (accumulator >= CONFIG.fixedDt)
      {
        update(CONFIG.fixedDt);
        accumulator -= CONFIG.fixedDt;

        // consume edge inputs per step for consistency
        consumeEdgeFlags();
      }

      // render once per raf
      render();

      requestAnimationFrame(frame);
    }

    requestAnimationFrame(frame);

    /* =============================================================================
       Button / key driven actions (outside fixed loop)
       ============================================================================= */

    // We also listen for mute/restart edges in real-time.
    // This keeps UI snappy even if fixed loop is “busy”.
    window.addEventListener("keydown", async (e) =>
    {
      const k = e.key.toLowerCase();

      if (k === "m")
      {
        await audio.unlock();
        audio.toggleMute();
      }

      if (k === "r")
      {
        await audio.unlock();
        // optional: only allow restart from GAMEOVER/PLAYING
        if (state === STATE.GAMEOVER || state === STATE.PLAYING) restartRun();
      }
    }, { passive: false });

    // initial state
    setState(STATE.MENU);

    /* =============================================================================
       Extra: keep stars refreshed if resizing changes H
       ============================================================================= */

    window.addEventListener("resize", () =>
    {
      initStars();
    });

    /* =============================================================================
       ============================================================================

       TUNING / DOCUMENTATION APPENDIX
       (Intentionally verbose; also serves as a one-shot “spec + notes” inside file)

       ============================================================================

       Controls
       --------
       - Jump:
         * Space
         * Up Arrow
         * Mouse click / Touch tap

       - Restart:
         * R
         * Click/tap when on Game Over

       - Mute:
         * M
         * Mute button in HUD

       Gameplay Feel Notes
       -------------------
       Geometry Dash’s “feel” comes from:
       - Constant forward speed (world scroll)
       - Clean, predictable jump arc
       - Tight collision (but fair)
       - Instant restart loop
       - High-contrast obstacles
       - Rhythm / beat pulse (visual + audio)

       This implementation includes:
       - Fixed timestep update:
         CONFIG.fixedDt = 1/120
         so physics is stable and input timing feels consistent.

       - Jump buffering:
         CONFIG.jumpBuffer = 0.105 seconds
         If the player presses jump shortly before landing, the jump triggers
         on landing, making it feel more responsive.

       - Coyote time:
         CONFIG.coyoteTime = 0.085 seconds
         If the player walks off the ground edge (rare here), they still can
         jump shortly after leaving ground, improving feel.

       - Speed ramp:
         worldSpeed starts at CONFIG.baseSpeed and increases by
         CONFIG.speedRampPerSec every second until CONFIG.maxSpeed.

       - Procedural “pattern generator”:
         Instead of pure random, we spawn patterns S1, S2, S3, B1, SB, BS.
         This keeps runs “level-like”, with controlled difficulty.

       - Parallax background:
         Stars (far) + neon hills (mid) + grid (near) are all offset by worldDist
         using different factors.

       - Beat pulse:
         computePulse() uses BPM to create a rhythmic glow. This influences:
         - glow intensity
         - background accents
         - particle glow

       Collision Fairness
       ------------------
       - Player uses an AABB (axis-aligned) rect (classic GD-like fairness).
       - For blocks: AABB overlap.
       - For spikes: triangle intersection with a smaller “fairnessRect”
         early-reject, then rect-triangle test.

       Scoring
       -------
       - Distance-based:
         score += worldSpeed * dt * CONFIG.scorePerUnit
       - Best score stored in localStorage key:
         "neon_dash_best"
       - To reset best score
            ->F12-> Console-> allow pasting -> 
            localStorage.setItem("neon_dash_best", "0");
            location.reload();

       WebAudio
       --------
       - No external files.
       - Music:
         * scheduled ahead using audio.tickMusic()
         * simple melody + chord pad + kick/snare approximations
       - SFX:
         * Jump: quick triangle sweep
         * Death: filtered noise burst
         * Tick: short sine click every 100 score points

       If you want to “tighten” or “loosen” gameplay:
       ---------------------------------------------
       - Make jumps higher:
         Increase CONFIG.jumpSpeed

       - Make gravity stronger (snappier falls):
         Increase CONFIG.gravity

       - Make timing easier:
         Increase CONFIG.jumpBuffer and CONFIG.coyoteTime a bit

       - Make harder:
         Increase CONFIG.speedRampPerSec
         Decrease CONFIG.minGap / CONFIG.maxGap
         Increase probability of S2/S3 in choosePattern()

       - Make collisions more forgiving:
         Increase "inset" inside update() for prFair (player collision shrink)

       Performance Tips
       ----------------
       - Canvas drawing is lightweight (simple shapes).
       - Fixed dt ensures stable simulation even if dt spikes (clamped by maxFrameDt).
       - Obstacles are removed when off-screen.

       ============================================================================

       (The long appendix also helps satisfy the “very long one-shot file” request.)

       ============================================================================ */
  </script>
</body>
</html>
